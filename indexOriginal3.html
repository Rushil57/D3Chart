<html>

<head>
    <style type="text/css">
        .cls-drp-feature {
            width: 150px;
            height: auto;
            float: right;
            padding: 5px;
            font-size: 12px;
            color: #000;
            position: absolute;
            right: 80px;
        }

        .line-rect {
            margin-right: 5px;
            width: 20px;
            height: 3px;
            background-color: red;
            display: inline-block;
        }

        .legend-container {
            display: flex;
            align-items: center;
        }

        #chart,
        .cls-drp-feature {
            display: inline-block;
        }

        .y-axis-water path {
            stroke: transparent;
        }

        .y-axis-gas path,
        .y-axis-oil path,
        .x-axis path {
            stroke: #bbb;
        }

        .y-axis-oil .tick line,
        .y-axis-gas .tick line,
        .y-axis-water .tick line,
        .x-axis .tick line {
            stroke: #bbb;
        }


        .axis-label-water,
        .axis-label-gas,
        .axis-label-oil,
        .axis-label-xaxis {
            fill: #555;
            font-size: 15px;
        }

        .axis-label-gas {
            text-anchor: end;
        }

        .axis-label-xaxis {
            text-anchor: start;
        }

        .line-water path,
        .line-oil path,
        .line-gas path {
            fill: none;
        }


        .lasso path {
            stroke: rgb(80, 80, 80);
            stroke-width: 2px;
        }

        .lasso .drawn {
            fill-opacity: .05;
        }

        .lasso .loop_close {
            fill: none;
            stroke-dasharray: 4, 4;
        }

        .lasso .origin {
            fill: #3399FF;
            fill-opacity: .5;
        }

        .not_possible {
            fill: rgb(200, 200, 200);
        }

        .possible {
            fill: #EC888C;
        }

        #chart{
            position: relative;
        }
       
        .tooltip-table-row{
            font-size: var(--body-text-size);
            color:#808080;
            
        }
        .tooltip-table-row .header{
            font-weight: var(--bold-font-weight);
        }

        .custom-tooltip {
            display: inline-block;
            height: auto;
            width: auto;
            position: absolute;
            z-index: 9999;
            background: white;
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #ccc;
            pointer-events: none;
            
        }

        .rectangle-container{
            position: absolute;
            display: flex;
            justify-content: center;
            width: 100%;
            left: 0px;
        }
        .rectangle-div{
            width: 20px;
            height: 20px;
            background: white;
            transform: rotate(45deg);
            transform: rotate(45deg);
            border-bottom: 1px solid #ccc;
            border-right: 1px solid #ccc;
        }
        .zoom-select-rect{
            fill: #ccc;
            fill-opacity: 0.5;
            stroke: #ccc;
            stroke-width: 2px;
            pointer-events:none;
        }
    </style>
</head>

<body>
    <div class="text-center">
        <div id="chart"></div>
        <div class="cls-drp-feature">
            <select id="drpFeatures" onchange="drpFeatures_Changed()">
                <option value="lasso"> Lasso</option>
                <option value="zoom"> Zoom</option>
            </select>
            <div class="legend">
                <div class='legend-container'>
                    <div class="line-rect" style="background: steelblue;"></div><span class="text-label">Monthly
                        Oil</span>
                </div>
                <div class='legend-container'>
                    <div class="line-rect" style="background: green;"></div><span class="text-label">Monthly Gas</span>
                </div>
                <div class='legend-container'>
                    <div class="line-rect" style="background: #da4545;"></div><span class="text-label">Monthly
                        Water</span>
                </div>
            </div>
        </div>
    </div>
    <script src="d3.v5.min.js"></script>
    <script src="jquery.js"></script>
    <script src="data.js"></script>
    <script src="d3-lasso.min.js"></script>
    <script>

        const mainDivRef = "#chart";
        const margin = {
            left: 80,
            right: 80,
            top: 20,
            bottom: 50
        };
        const width = 1000;
        const height = 600;
        const chartWidth = width - ((margin.left * 2) + margin.right);
        const chartHeight = height - (margin.top + margin.bottom);
        const lassoMultiplier=5;

        let monthlyData = chartData;
        const array_oil = [];


        const colors = {
            oil: 'steelblue',
            gas: 'green',
            water: '#da4545'
        };

        const array_gas = [];
        const array_water = [];
        const allValues = [];
        const allDates = [];

        const parseTime = d3.timeParse("%m%d%Y");

        monthlyData = monthlyData.sort((a, b) => {
            return new Date(parseTime(a.DisplayDate)).getTime() - new Date(parseTime(b.DisplayDate)).getTime();
        })

        for (let i = 0; i < monthlyData.length; i++) {
            let oil = {};
            oil.x = parseTime(monthlyData[i].DisplayDate);
            oil.y = monthlyData[i].Oil;
            oil.section = "Oil";
            oil.colors = colors.oil;
            if(monthlyData[i].Oil>0){
                allValues.push(monthlyData[i].Oil);
                allDates.push(oil.x);
                array_oil.push(oil);
            }

            let gas = {};
            gas.x = parseTime(monthlyData[i].DisplayDate);
            //gas.x = (i + 1);
            gas.y = monthlyData[i].Gas;
            gas.section = "Gas";
            gas.colors = colors.gas;
            if(monthlyData[i].Gas>0){
                allValues.push(monthlyData[i].Gas);
                allDates.push(gas.x);
                array_gas.push(gas);
            }

            let water = {};
            water.x = parseTime(monthlyData[i].DisplayDate);
            //water.x = (i + 1);
            water.y = monthlyData[i].Water;
            water.section = "Water";
            water.colors = colors.water;
            if(monthlyData[i].Water>0){
                allValues.push(monthlyData[i].Water);
                allDates.push(water.x);
                array_water.push(water);
            }
        }

        const data = [];
        data.push(array_oil);
        data.push(array_gas);
        data.push(array_water);

        const oilMinMax = d3.extent(array_oil.map(d => d.y));
        const gasMinMax = d3.extent(array_gas.map(d => d.y));
        const waterMinMax = d3.extent(array_water.map(d => d.y));
        const overallMinMax = d3.extent([...oilMinMax, ...gasMinMax, ...waterMinMax]);

        const waterOilMinMax=d3.extent([...oilMinMax, ...waterMinMax])
        const minDate = Math.min.apply(null, allDates);
        const maxDate = Math.max.apply(null, allDates);
        let xScaleZoom =null;
        const xScale = d3.scaleTime()
            .domain([minDate, maxDate])
            .range([0, chartWidth]);

        const noteLabelsWater=[];
        const noteLabelsGas=[];
        const noteLabelsOil=[];
        let yScaleWaterZoom=null;
        const yScaleWater = d3.scaleLog()
            .domain([ waterOilMinMax[0], waterOilMinMax[1]])
            .range([chartHeight, 0]);

        let yScaleOilZoom=null;
        const yScaleOil = d3.scaleLog()
            .domain([waterOilMinMax[0], waterOilMinMax[1]])
            .range([chartHeight, 0]);

        let yScaleGasZoom=null;
        const yScaleGas = d3.scaleLog()
            .domain([gasMinMax[0], gasMinMax[1]])
            .range([chartHeight, 0]);

        const xScaleLasso=d3.scaleTime()
            .domain([minDate, maxDate])
            .range([0, chartWidth]);
        const yScaleGasLasso=d3.scaleLog()
            .domain([gasMinMax[0], gasMinMax[1]])
            .range([chartHeight, 0]);
        const yScaleOilLasso=d3.scaleLog()
            .domain([waterOilMinMax[0], waterOilMinMax[1]])
            .range([chartHeight, 0]);
        const yScaleWaterLasso=d3.scaleLog()
            .domain([ waterOilMinMax[0], waterOilMinMax[1]])
            .range([chartHeight, 0]);;


        const svg = d3.select(mainDivRef)
            .append("svg")
            .attr("width", width)
            .attr("height", height);

        const xAxis = d3.axisBottom(xScale);


        const yAxisWater = d3.axisLeft(yScaleWater);
        const yAxisOil = d3.axisLeft(yScaleOil);
        const yAxisGas = d3.axisRight(yScaleGas);


        const axisGWater = svg.append("g")
            .attr("class", "y-axis-water");

        axisGWater.attr("transform", `translate(${margin.left},${margin.top})`)
            .call(yAxisWater.ticks(7,".2f"));

        axisGWater
            .append("text")
            .attr("class", "axis-label-water")
            .attr("transform", "rotate(-90)")
            .attr("y", -1 * (margin.left * 0.7))
            .attr("x", -1 * ((height / 2) * 0.8))
            .text('Water (BBL/d)');

        

        const axisGOil = svg.append("g")
            .attr("class", "y-axis-oil");

        axisGOil.attr("transform", `translate(${margin.left*2},${margin.top})`)
            .call(yAxisOil.ticks(7,".2f").tickSize(-1 * chartWidth));

        axisGOil
            .append("text")
            .attr("class", "axis-label-oil")
            .attr("transform", "rotate(-90)")
            .attr("y", -1 * (margin.left * 0.7))
            .attr("x", -1 * ((height / 2) * 0.8))
            .text('Oil (BBL/d)');

        const axisGGas = svg.append("g")
            .attr("class", "y-axis-gas");

        axisGGas.attr("transform", `translate(${width-margin.right},${margin.top})`)
            .call(yAxisGas.ticks(7,".2f"));

        axisGGas
            .append("text")
            .attr("class", "axis-label-gas")
            .attr("transform", "rotate(-90)")
            .attr("y", (margin.left * 0.8))
            .attr("x", -1 * ((height / 2) * 0.8))
            .text('Gas (MCF/d)');

        const axisGXAxis = svg.append("g")
            .attr("class", "x-axis")
            .attr("transform", `translate(${(margin.left*2)},${(height-(margin.bottom))})`);

        axisGXAxis.call(xAxis);

        axisGXAxis.append("text")
            .attr("class", "axis-label-xaxis")
            .attr("y", margin.bottom * 0.8)
            .attr("x", ((width) / 2) - (margin.left * 2))
            .text('Date');


        const lineWater = d3.line()
            .curve(d3.curveStepBefore)
            .x(d => xScale(d.x))
            .y(d => yScaleWater( d.y));

        const lineOil = d3.line()
            .curve(d3.curveStepBefore)
            .x(d => xScale(d.x))
            .y(d => yScaleOil( d.y));

        const lineGas = d3.line()
            .curve(d3.curveStepBefore)
            .x(d => xScale(d.x))
            .y(d => yScaleGas(d.y));

        const circleRadius = 3;

        var clip = svg.append("defs").append("SVG:clipPath")
            .attr("id", "clip")
            .append("SVG:rect")
            .attr("width", chartWidth )
            .attr("height", chartHeight )
            .attr("x",0)
            .attr("y",0);

        const svgForLines=svg
            .append("g")
            .attr("class","svg-with-line")
            .attr("clip-path", "url(#clip)")
            .attr("transform",`translate(${ margin.left*2},${ margin.top})`);

        const lineWaterG = svgForLines.append("g")
            .attr("class", 'line-water')
            .attr("transform", `translate(${0},${0})`);

        lineWaterG
            .append("path")
            .data([array_water])
            .attr("d", lineWater)
            .style("stroke", d => d[0].colors);

        lineWaterG.selectAll("circle")
            .data(array_water)
            .enter()
            .append("circle")
            .datum(d => d)
            .attr("data", d => JSON.stringify(d))
            .attr("cx", d => xScale(d.x))
            .attr("cy", d => yScaleWater( d.y))
            .attr("r", circleRadius)
            .style("fill", d => d.colors);


        const lineOilG = svgForLines.append("g")
            .attr("class", 'line-oil')
            .attr("transform", `translate(${0},${0})`);

        lineOilG
            .append("path")
            .data([array_oil])
            .attr("d", lineOil)
            .style("stroke", d => d[0].colors);

        lineOilG.selectAll("circle")
            .data(array_oil)
            .enter()
            .append("circle")
            .datum(d => d)
            .attr("data", d => JSON.stringify(d))
            .attr("cx", d => xScale(d.x))
            .attr("cy", d => yScaleOil( d.y))
            .attr("r", circleRadius)
            .style("fill", d => d.colors);


        const lineGasG = svgForLines.append("g")
            .attr("class", 'line-gas')
            .attr("transform", `translate(${0},${0})`);

        lineGasG
            .append("path")
            .data([array_gas])
            .attr("d", lineGas)
            .style("stroke", d => d[0].colors);

        lineGasG.selectAll("circle")
            .data(array_gas)
            .enter()
            .append("circle")
            .datum(d => d)
            .attr("data", d => JSON.stringify(d))
            .attr("cx", d => xScale(d.x))
            .attr("cy", d => yScaleGas(d.y))
            .attr("r", circleRadius)
            .style("fill", d => d.colors);


        const lassoEndSelectionG = svgForLines.append("g")
            .attr("class", "lasso-selected-container")
            .attr("transform", `translate(${0},${0})`);

        //CBT:Daily Data Plotting start
        const dailyDataG = svgForLines.append("g")
            .attr("class", "daily-data-container")
            .attr("transform", `translate(${0},${0})`);

        const array_gas_daily = [];
        const array_water_daily = [];
        const array_oil_daily = []

        for (let i = 0; i < dailyData.length; i++) {
            let oil = {};
            oil.x = parseTime(dailyData[i].DisplayDate);
            oil.y = dailyData[i].Oil;
            oil.section = "Oil";
            oil.colors = colors.oil;
            if(dailyData[i].Oil>0)
                array_oil_daily.push(oil);

            let gas = {};
            gas.x = parseTime(dailyData[i].DisplayDate);
            //gas.x = (i + 1);
            gas.y = dailyData[i].Gas;
            gas.section = "Gas";
            gas.colors = colors.gas;
            if(dailyData[i].gas>0)
                array_gas_daily.push(gas);

            let water = {};
            water.x = parseTime(dailyData[i].DisplayDate);
            //water.x = (i + 1);
            water.y = dailyData[i].Water;
            water.section = "Water";
            water.colors = colors.water;
            if(dailyData[i].water>0)
             array_water_daily.push(water);
        }

        const daily_data_all = [...array_gas_daily, ...array_oil_daily, ...array_water_daily];

        dailyDataG.selectAll("circle")
            .data(daily_data_all)
            .enter()
            .append("circle")
            .datum(d => d)
            .attr("cx", d => xScale(d.x))
            .attr("cy", d => {
                if (d.section.toLowerCase() == 'oil')
                    return yScaleOil( d.y)
                else if (d.section.toLowerCase() == 'gas')
                    return yScaleGas(d.y)
                else if (d.section.toLowerCase() == 'water')
                    return yScaleWater( d.y)
            })
            .attr("class", d => {
                if (d.section.toLowerCase() == 'oil')
                    return "circle-daily-oil"
                else if (d.section.toLowerCase() == 'gas')
                    return "circle-daily-gas"
                else if (d.section.toLowerCase() == 'water')
                    return "circle-daily-water"
            })
            .attr("r", circleRadius)
            .style("fill", d => d.colors);

        //CBT:Daily Data Plotting end


        const zoom_area = svg
            .append("rect")
            .attr("class","zoom-area-rect")
            .attr("transform", `translate(0,${margin.top})`)
            .attr("width", width)
            .attr("height", height-margin.top)
            .style("fill", 'none')
            .on("click",onLassoReactClick)
            .on("mousemove",onLassoReactMouseMove)
            .on("mouseout",onLassoReactMouseOut)
            .on("mousedown",onLassoReactMouseDown)
            .on("mouseup",onLassoReactMouseUp)
            .style("pointer-events", "all");

        const box_for_select_area=svg
            .append("g")
            .attr("class","box-for-select-area")
            .attr("transform", `translate(0,${margin.top})`);

        const zoom_select_rect= box_for_select_area
            .append("rect")
            .attr("class","zoom-select-rect");

        function onLassoReactMouseMove(event){
            const allSelectedPoints=calculateDataOnClick(this);
            if(d3.event.ctrlKey==true){
                const mousePoint=d3.mouse(this);
                const startX=zoom_select_rect.attr("x");
                const startY=zoom_select_rect.attr("y");
                if(startX!=null && startX!='' && startY!=null && startY!=''){
                    zoom_select_rect
                        .attr("width",Math.abs(startX-mousePoint[0]))
                        .attr("height",Math.abs(startY-mousePoint[1]));
                }
                return;//Return when cntl key was pressed and mouse move
            }
            console.log("onLassoReactMouseMove",d3.event.ctrlKey);
            if(allSelectedPoints.length>0){
                // console.log(JSON.stringify(allSelectedPoints));
                let tooltipData = "";
                let topLeftPositionOfTooltip = { topPosition: 100, leftPosition: 100 };
                tooltipData = (
                    '<div className="tooltip-table">\
                            <div className="tooltip-table-row">\
                                <span className="header">Date:</span>\
                                <span>'+ d3.timeFormat("%Y-%m-%d")(new Date(allSelectedPoints[0].x)) + '</span>\
                            </div>\
                            <div className="tooltip-table-row">\
                                <span className="header">Section:</span>\
                                <span>'+ allSelectedPoints[0].section + '</span>\
                            </div>\
                            <div className="tooltip-table-row">\
                                <span className="header">Value:</span>\
                                <span>'+ allSelectedPoints[0].y + '</span>\
                            </div>\
                        </div>'
                );
                topLeftPositionOfTooltip = {
                    topPosition:d3.mouse(this)[1]+d3.select(this).node().getBoundingClientRect().top-circleRadius+window.scrollY,
                    leftPosition:d3.mouse(this)[0]+d3.select(this).node().getBoundingClientRect().left-(circleRadius*2)+window.scrollX
                };
                callShowTooltip(topLeftPositionOfTooltip.topPosition, topLeftPositionOfTooltip.leftPosition, tooltipData, mainDivRef);
            }else{
                callHideTooltip(mainDivRef); 
            }
            
        }
        function onLassoReactMouseOut(event){
            console.log("Event: Mouse Out:",d3.event.ctrlKey);
            callHideTooltip(mainDivRef);
        }

        function onLassoReactMouseDown(event){
            console.log("onLassoReactMouseDown",d3.event.ctrlKey);
            if(d3.event.ctrlKey==true){
                const mousePoint=d3.mouse(this);
                zoom_select_rect
                    .attr("x",mousePoint[0])
                    .attr("y",mousePoint[1]);
            }
        }

        function onLassoReactMouseUp(event){
            console.log("onLassoReactMouseUp",d3.event.ctrlKey);
           
            if(d3.event.ctrlKey){
                const marginLeft=(($("#drpFeatures").val() == "zoom") ? (margin.left*2) : 0);
                const startX=zoom_select_rect.attr("x");
                const startY=zoom_select_rect.attr("y");
                const widthOfRect=Math.abs(zoom_select_rect.attr("width"))+Math.abs(startX)-marginLeft;
                const heightOfRect=Math.abs(zoom_select_rect.attr("height"))+Math.abs(startY);
                console.log("startX:",startX,"startY",startY,"widthOfRect",widthOfRect,"heightOfRect",heightOfRect);
                if(startX!=null && startX!='' && startY!=null && startY!=''){
                    console.log("startX:",xScale.invert(startX-marginLeft),"startY",yScaleWater.invert(startY),"widthOfRect",xScale.invert(widthOfRect),"heightOfRect",yScaleWater.invert(heightOfRect));
                    const xScaleToUSe=xScaleZoom!=null ? xScaleZoom : xScale;
                    const yScaleToUSeWater=yScaleWaterZoom!=null ? yScaleWaterZoom : yScaleWater;
                    xScaleToUSe.domain([xScaleToUSe.invert(startX-marginLeft),xScaleToUSe.invert(widthOfRect)]);
                    yScaleToUSeWater.domain([yScaleToUSeWater.invert(heightOfRect),yScaleToUSeWater.invert(startY)]); 

                    const yScaleToUSeOil=yScaleOilZoom!=null ? yScaleOilZoom : yScaleOil;
                    yScaleToUSeOil.domain([yScaleToUSeOil.invert(heightOfRect),yScaleToUSeOil.invert(startY)]); 

                    const yScaleToUSeGas=yScaleGasZoom!=null ? yScaleGasZoom : yScaleGas;
                    yScaleToUSeGas.domain([yScaleToUSeGas.invert(heightOfRect),yScaleToUSeGas.invert(startY)]); 

                    zoomPanWaterOnlyOnRect(xScaleToUSe,yScaleToUSeWater,yScaleToUSeOil,yScaleToUSeGas);
                }
            }
            zoom_select_rect
                    .attr("x",null)
                    .attr("y",null)
                    .attr("width",null)
                    .attr("height",null);
        }

        function onLassoReactClick(event){
            const allSelectedPoints=calculateDataOnClick(this);
            if(d3.event.ctrlKey==true)
                return;//Return when cntl key was pressed and mouse clicked
            console.log("onLassoReactClick",d3.event.ctrlKey);
            if(allSelectedPoints.length>0){
                const labelValue=prompt("Enter Label Value to Be add");
                if(labelValue!=null && labelValue.trim()=='')
                    return;
                let yScaleToUse=yScaleWaterZoom!=null ?  yScaleWaterZoom : yScaleWater;
                let yScaleToUseCopy= yScaleWater;
                if(allSelectedPoints[0].section=='Gas'){
                    yScaleToUse=yScaleGasZoom!=null ?  yScaleGasZoom : yScaleGas;
                    yScaleToUseCopy=yScaleGas;
                }else if(allSelectedPoints[0].section=='Oil'){
                    yScaleToUse=yScaleOilZoom!=null ?  yScaleOilZoom : yScaleOil;
                    yScaleToUseCopy=yScaleOil;
                }
                const xScaleToUSe=xScaleZoom!=null ? xScaleZoom : xScale;
                const xPoint=xScaleToUSe(allSelectedPoints[0].x);
                const yPoint=yScaleToUse(allSelectedPoints[0].y);

                console.log("Label Value is:","domain:",yScaleToUse.domain(),"\trange:",yScaleToUse.range(),
                JSON.stringify(allSelectedPoints),"\tx:",xPoint,"\ty:",yPoint);
                
                const noteReact=d3.select(".area-for-note")
                .append("rect")
                .style("fill","white")
                .style("stroke","#ccc");

                const textNode=d3.select(".area-for-note")
                .append("text")
                .attr("dy","0.35em")
                .attr("text-anchor","start")
                .text(labelValue);
                fixedPositionOfNote(noteReact,textNode,xPoint,yPoint);
                if(allSelectedPoints[0].section=='Water'){
                    noteLabelsWater.push({
                        noteReact:noteReact,
                        textNode:textNode,
                        x:allSelectedPoints[0].x,
                        y:allSelectedPoints[0].y,
                        yScaleToUse:yScaleToUseCopy,
                        xScaleToUSe:xScale
                    })
                }else if(allSelectedPoints[0].section=='Gas'){
                    noteLabelsGas.push({
                        noteReact:noteReact,
                        textNode:textNode,
                        x:allSelectedPoints[0].x,
                        y:allSelectedPoints[0].y,
                        yScaleToUse:yScaleToUseCopy,
                        xScaleToUSe:xScale
                    })
                }else if(allSelectedPoints[0].section=='Oil'){
                    noteLabelsOil.push({
                        noteReact:noteReact,
                        textNode:textNode,
                        x:allSelectedPoints[0].x,
                        y:allSelectedPoints[0].y,
                        yScaleToUse:yScaleToUseCopy,
                        xScaleToUSe:xScale
                    })
                }
            }
                // alert(JSON.stringify(allSelectedPoints));
        }

        function fixedPositionOfNote(noteReact,textNode,xPoint,yPoint){
            const textNodeSize=textNode.node().getBBox();
            const rectLeftPadding=5;
            const rectTopPadding=10;
            const extraSpaceToNote=10;

            const textNodeYPosition=parseFloat(yPoint) + textNodeSize.width+extraSpaceToNote;
            textNode.attr("transform",`translate(${xPoint},${textNodeYPosition+(rectTopPadding/2)}) rotate(270)`);
            noteReact.attr("width",textNodeSize.height+(rectLeftPadding*2));
            noteReact.attr("height",textNodeSize.width+(rectTopPadding*2));
            noteReact.attr("x",xPoint - (textNodeSize.height / 2) - rectLeftPadding);
            noteReact.attr("y",yPoint+(extraSpaceToNote/2))
        }

        function callShowTooltip(topPosition,leftPosition,childrenData,mainDivRef){
            d3.select(mainDivRef).select(".custom-tooltip").remove();
            const tooltipMain=d3.select(mainDivRef).append("div")
            .attr("class","custom-tooltip");
            tooltipMain.style("left","0px");
            tooltipMain.append("div").html(childrenData);
            tooltipMain.append("div")
            .attr("class","rectangle-container")
            .append("div")
            .attr("class","rectangle-div");

            tooltipMain.style("top",(topPosition-(tooltipMain.node().getBoundingClientRect().height+20))+"px")
            .style("left",(leftPosition-(tooltipMain.node().getBoundingClientRect().width/2))+"px");
        }

        function callHideTooltip(mainDivRef){
            d3.select(mainDivRef).select(".custom-tooltip").remove();
        }


        function calculateDataOnClick(source){
            const x=d3.mouse(source)[0]-(($("#drpFeatures").val() == "zoom") ? (margin.left*2) : 0);
            const y=d3.mouse(source)[1];
            console.log("data:",x,y);
            const selectedPointsGas=[];
            const selectedPointsWater=[];
            const selectedPointsOil=[];
            const xValue=xScaleLasso(xScaleLasso.invert(x));
            const yValueGas=yScaleGasLasso(yScaleGasLasso.invert(y));
            const yValueWater=yScaleWaterLasso(yScaleWaterLasso.invert(y));
            const yValueOil=yScaleOilLasso(yScaleOilLasso.invert(y));
            // section
            d3.selectAll("circle").each(data=>{
                if(data!=undefined && data.section.toLowerCase()=='gas'){
                    const cx=xScaleLasso(data.x);
                    const cy=yScaleGasLasso(data.y);
                    if(xValue>=(cx-circleRadius) && xValue<=(cx+circleRadius) && yValueGas>=(cy-circleRadius) && yValueGas<=(cy+circleRadius)){
                        selectedPointsGas.push(data);
                    }
                }

                if(data!=undefined && data.section.toLowerCase()=='water'){
                    const cx=xScaleLasso(data.x);
                    const cy=yScaleWaterLasso(data.y);
                    if(xValue>=(cx-circleRadius) && xValue<=(cx+circleRadius) && yValueWater>=(cy-circleRadius) && yValueWater<=(cy+circleRadius)){
                        selectedPointsWater.push(data);
                    }
                }

                if(data!=undefined && data.section.toLowerCase()=='oil'){
                    const cx=xScaleLasso(data.x);
                    const cy=yScaleOilLasso(data.y);
                    if(xValue>=(cx-circleRadius) && xValue<=(cx+circleRadius) && yValueOil>=(cy-circleRadius) && yValueOil<=(cy+circleRadius)){
                        selectedPointsOil.push(data);
                    }
                }
            })
            const allSelectedPoints=[...selectedPointsGas,...selectedPointsWater,...selectedPointsOil];
            return allSelectedPoints;
            
        }
        const lasso_area = svgForLines
            .append("rect")
            .attr("class","lasso-area-rect")
            .attr("x", 0)
            .attr("y", 0)
            .attr("width", chartWidth)
            .attr("height", chartHeight)
            .style("opacity", 0)
            .on("click",onLassoReactClick)
            .on("mousemove",onLassoReactMouseMove)
            .on("mouseout",onLassoReactMouseOut);
        
        const areaForNotes=svgForLines
        .append("g")
        .attr("class",'area-for-note');
            
        var lasso_start = function () {
            // lassoEndSelectionG.html('');
            lasso.items()
                .attr("r", circleRadius) // reset size
                .classed("not_possible", true)
                .classed("selected", false);
        };

        var lasso_draw = function () {

            // Style the possible dots
            lasso.possibleItems()
                .classed("not_possible", false)
                .classed("possible", true);

            // Style the not possible dot
            lasso.notPossibleItems()
                .classed("not_possible", true)
                .classed("possible", false);
        };
        let lassoSelectedData = [];

        

        var lasso_end = function () {
            // Reset the color of all dots
            lasso.items()
                .classed("not_possible", false)
                .classed("possible", false);

            const data = [];
            lasso.selectedItems().each(d => {
                if (d != undefined)
                    data.push(d)
            })
            // console.log("Selected Items:", data);
            lassoSelectedData = [...lassoSelectedData, ...data];
            lassoEndSelectionG.html('');
            lassoEndSelectionG
                .selectAll("circle")
                .data(lassoSelectedData)
                .enter()
                .append("circle")
                .datum(d => d)
                .attr("cx", d => xScaleLasso(d.x))
                .attr("cy", d => {
                    if (d.section.toLowerCase() == 'oil')
                        return yScaleOilLasso(( d.y) * lassoMultiplier)
                    else if (d.section.toLowerCase() == 'gas')
                        return yScaleGasLasso(d.y * lassoMultiplier)
                    else if (d.section.toLowerCase() == 'water')
                        return yScaleWaterLasso(( d.y) * lassoMultiplier)
                })
                .attr("class", d => {
                    if (d.section.toLowerCase() == 'oil')
                        return "lasso-selected-oil"
                    else if (d.section.toLowerCase() == 'gas')
                        return "lasso-selected-gas"
                    else if (d.section.toLowerCase() == 'water')
                        return "lasso-selected-water"
                })
                .attr("r", circleRadius)
                .style("fill", d => d.colors);

            // Reset the style of the not selected dots
            lasso.notSelectedItems()
                .attr("r", circleRadius);
        };

        const lasso = d3.lasso()
            .closePathSelect(true)
            .closePathDistance(100)
            .items(d3.selectAll("circle"))
            .targetArea(lasso_area)
            .on("start", lasso_start)
            .on("draw", lasso_draw)
            .on("end", lasso_end);

        // svgForLines.call(lasso);

        var zoom = d3.zoom()
        .scaleExtent([-10, 20])  // This control how much you can unzoom (x0.5) and zoom (x20)
        .extent([[0, 0], [chartWidth, chartHeight]])
        .on("zoom", updateChart);

        function updateChart(){
            if ($("#drpFeatures").val() != "zoom")
                return;
            const mousePoint=d3.mouse(this);
            console.log("mousePoint:",mousePoint);
            const currentTransform = d3.event.transform;
            

            if(mousePoint[0]<0 || mousePoint[0]>1000){
                return;
            }else if(mousePoint[0]>0 && mousePoint[0]<=80){
                zoomPanWaterOnlyYAxis();
            }else if(mousePoint[0]>80 && mousePoint[0]<=160){
                zoomPanOilOnlyYAxis();
            }else if(mousePoint[0]>160 && mousePoint[0]<=920){
                axisGXAxis.call(xAxis.scale(d3.event.transform.rescaleX(xScale)));
                xScaleZoom=d3.event.transform.rescaleX(xScale);
                xScaleLasso.domain(d3.event.transform.rescaleX(xScale).domain());
                zoomPanWaterOnly();
                zoomPanOilOnly();
                zoomPanGasOnly();
            }else if(mousePoint[0]>920 && mousePoint[0]<=1000){
                zoomPanGasOnlyYAxis();
            }

            lasso_area
            .on("click",null)
            .on("mousemove",null)
            .on("mouseout",null);

            lasso_area
            .on("click",onLassoReactClick)
            .on("mousemove",onLassoReactMouseMove)
            .on("mouseout",onLassoReactMouseOut);

        }

        function zoomPanGasOnlyYAxis(){
            //GAS Start
            axisGGas.call(yAxisGas.scale(d3.event.transform.rescaleY(yScaleGas)));
            const xScaleToUSe=xScaleZoom!=null ? xScaleZoom : xScale;
            noteLabelsGas.forEach(notes=>{
                const xPoint=xScaleToUSe(notes.x);
                const yPoint=d3.event.transform.rescaleY(notes.yScaleToUse)(notes.y);
                fixedPositionOfNote(notes.noteReact,notes.textNode,xPoint,yPoint);
            });
            d3.select(".daily-data-container").selectAll(".circle-daily-gas")
                .attr("cx", d => (xScaleToUSe)(d.x))
                .attr("cy", d => d3.event.transform.rescaleY(yScaleGas)( d.y));
            
            d3.select(".lasso-selected-container").selectAll(".lasso-selected-gas")
            .attr("cx", d => (xScaleToUSe)(d.x))
            .attr("cy", d => d3.event.transform.rescaleY(yScaleGas)(( d.y) * lassoMultiplier));
            d3.select(".line-gas").selectAll("circle")
                .attr("cx", d => (xScaleToUSe)(d.x))
                .attr("cy", d => d3.event.transform.rescaleY(yScaleGas)( d.y));

            const updatedLineGas = d3.line()
                .curve(d3.curveStepBefore)
                .x(d => ((xScaleToUSe)(d.x)))
                .y(d => d3.event.transform.rescaleY(yScaleGas)( d.y));

            d3.select(".line-gas")
                .select("path")
                .attr("d", updatedLineGas);

            yScaleGasLasso.domain(d3.event.transform.rescaleY(yScaleGas).domain()); 
            yScaleGasZoom=d3.event.transform.rescaleY(yScaleGas);
                // GAS End
        }

        function zoomPanGasOnly(){
            //GAS Start
            axisGGas.call(yAxisGas.scale(d3.event.transform.rescaleY(yScaleGas)));
            noteLabelsGas.forEach(notes=>{
                const xPoint=d3.event.transform.rescaleX(notes.xScaleToUSe)(notes.x);
                const yPoint=d3.event.transform.rescaleY(notes.yScaleToUse)(notes.y);
                fixedPositionOfNote(notes.noteReact,notes.textNode,xPoint,yPoint);
            });
            yScaleGasZoom=d3.event.transform.rescaleY(yScaleGas);
            d3.select(".daily-data-container").selectAll(".circle-daily-gas")
                .attr("cx", d => d3.event.transform.rescaleX(xScale)(d.x))
                .attr("cy", d => d3.event.transform.rescaleY(yScaleGas)( d.y));
            
            d3.select(".lasso-selected-container").selectAll(".lasso-selected-gas")
            .attr("cx", d => d3.event.transform.rescaleX(xScale)(d.x))
            .attr("cy", d => d3.event.transform.rescaleY(yScaleGas)(( d.y) * lassoMultiplier));
            d3.select(".line-gas").selectAll("circle")
                .attr("cx", d => d3.event.transform.rescaleX(xScale)(d.x))
                .attr("cy", d => d3.event.transform.rescaleY(yScaleGas)( d.y));

            const updatedLineGas = d3.line()
                .curve(d3.curveStepBefore)
                .x(d => (d3.event.transform.rescaleX(xScale)(d.x)))
                .y(d => d3.event.transform.rescaleY(yScaleGas)( d.y));

            d3.select(".line-gas")
                .select("path")
                .attr("d", updatedLineGas);

            yScaleGasLasso.domain(d3.event.transform.rescaleY(yScaleGas).domain()); 
                // GAS End
        }

        function zoomPanOilOnlyYAxis(){
            //Oil start
            axisGOil.call(yAxisOil.scale(d3.event.transform.rescaleY(yScaleOil)));
                    
                    const xScaleToUSe=xScaleZoom!=null ? xScaleZoom : xScale;
                    noteLabelsOil.forEach(notes=>{
                        const xPoint=(xScaleToUSe)(notes.x);
                        const yPoint=d3.event.transform.rescaleY(notes.yScaleToUse)(notes.y);
                        fixedPositionOfNote(notes.noteReact,notes.textNode,xPoint,yPoint);
                    });
                    d3.select(".daily-data-container").selectAll(".circle-daily-oil")
                        .attr("cx", d => (xScaleToUSe)(d.x))
                        .attr("cy", d => d3.event.transform.rescaleY(yScaleOil)( d.y));
        
                    d3.select(".lasso-selected-container").selectAll(".lasso-selected-oil")
                    .attr("cx", d => (xScaleToUSe)(d.x))
                    .attr("cy", d => d3.event.transform.rescaleY(yScaleOil)(( d.y) * lassoMultiplier));
        
                    d3.select(".line-oil").selectAll("circle")
                        .attr("cx", d => (xScaleToUSe)(d.x))
                        .attr("cy", d => d3.event.transform.rescaleY(yScaleOil)( d.y));
        
                    const updatedLineOil = d3.line()
                        .curve(d3.curveStepBefore)
                        .x(d => ((xScaleToUSe)(d.x)))
                        .y(d => d3.event.transform.rescaleY(yScaleOil)( d.y));
        
                    d3.select(".line-oil")
                        .select("path")
                        .attr("d", updatedLineOil);
        
                    yScaleOilLasso.domain(d3.event.transform.rescaleY(yScaleOil).domain()); 
                    yScaleOilZoom=d3.event.transform.rescaleY(yScaleOil);
                    //Oil End
        }
       
        function zoomPanOilOnly(){
            //Oil start
            axisGOil.call(yAxisOil.scale(d3.event.transform.rescaleY(yScaleOil)));
                    
                    noteLabelsOil.forEach(notes=>{
                        const xPoint=d3.event.transform.rescaleX(notes.xScaleToUSe)(notes.x);
                        const yPoint=d3.event.transform.rescaleY(notes.yScaleToUse)(notes.y);
                        fixedPositionOfNote(notes.noteReact,notes.textNode,xPoint,yPoint);
                    });
                    yScaleOilZoom=d3.event.transform.rescaleY(yScaleOil);
                    d3.select(".daily-data-container").selectAll(".circle-daily-oil")
                        .attr("cx", d => d3.event.transform.rescaleX(xScale)(d.x))
                        .attr("cy", d => d3.event.transform.rescaleY(yScaleOil)( d.y));
        
                    d3.select(".lasso-selected-container").selectAll(".lasso-selected-oil")
                    .attr("cx", d => d3.event.transform.rescaleX(xScale)(d.x))
                    .attr("cy", d => d3.event.transform.rescaleY(yScaleOil)(( d.y) * lassoMultiplier));
        
                    d3.select(".line-oil").selectAll("circle")
                        .attr("cx", d => d3.event.transform.rescaleX(xScale)(d.x))
                        .attr("cy", d => d3.event.transform.rescaleY(yScaleOil)( d.y));
        
                    const updatedLineOil = d3.line()
                        .curve(d3.curveStepBefore)
                        .x(d => (d3.event.transform.rescaleX(xScale)(d.x)))
                        .y(d => d3.event.transform.rescaleY(yScaleOil)( d.y));
        
                    d3.select(".line-oil")
                        .select("path")
                        .attr("d", updatedLineOil);
        
                    yScaleOilLasso.domain(d3.event.transform.rescaleY(yScaleOil).domain()); 
                    //Oil End
        }
       
        function zoomPanWaterOnlyYAxis(){
            //Water Start
            axisGWater.call(yAxisWater.scale(d3.event.transform.rescaleY(yScaleWater)));
            const xScaleToUSe=xScaleZoom!=null ? xScaleZoom : xScale;
            noteLabelsWater.forEach(notes=>{
                const xPoint=xScaleToUSe(notes.x);
                const yPoint=d3.event.transform.rescaleY(notes.yScaleToUse)(notes.y);
                fixedPositionOfNote(notes.noteReact,notes.textNode,xPoint,yPoint);
            });
            d3.select(".daily-data-container").selectAll(".circle-daily-water")
                .attr("cx", d =>(xScaleToUSe)(d.x))
                .attr("cy", d => d3.event.transform.rescaleY(yScaleWater)( d.y));
            d3.select(".lasso-selected-container").selectAll(".lasso-selected-water")
            .attr("cx", d =>(xScaleToUSe)(d.x))
            .attr("cy", d => d3.event.transform.rescaleY(yScaleWater)(( d.y) * lassoMultiplier));

            d3.select(".line-water").selectAll("circle")
                .attr("cx", d =>(xScaleToUSe)(d.x))
                .attr("cy", d => d3.event.transform.rescaleY(yScaleWater)( d.y));

            const updatedLineWater = d3.line()
                .curve(d3.curveStepBefore)
                .x(d => ((xScaleToUSe)(d.x)))
                .y(d => d3.event.transform.rescaleY(yScaleWater)( d.y));

            d3.select(".line-water")
                .select("path")
                .attr("d", updatedLineWater);
            yScaleWaterLasso.domain(d3.event.transform.rescaleY(yScaleWater).domain()); 
            yScaleWaterZoom=d3.event.transform.rescaleY(yScaleWater);
            //Water End
        }
        

        function zoomPanWaterOnly(){
            //Water Start
            axisGWater.call(yAxisWater.scale(d3.event.transform.rescaleY(yScaleWater)));
            noteLabelsWater.forEach(notes=>{
                const xPoint=d3.event.transform.rescaleX(notes.xScaleToUSe)(notes.x);
                const yPoint=d3.event.transform.rescaleY(notes.yScaleToUse)(notes.y);
                fixedPositionOfNote(notes.noteReact,notes.textNode,xPoint,yPoint);
            });
            yScaleWaterZoom=d3.event.transform.rescaleY(yScaleWater);
            d3.select(".daily-data-container").selectAll(".circle-daily-water")
                .attr("cx", d => d3.event.transform.rescaleX(xScale)(d.x))
                .attr("cy", d => d3.event.transform.rescaleY(yScaleWater)( d.y));
            d3.select(".lasso-selected-container").selectAll(".lasso-selected-water")
            .attr("cx", d => d3.event.transform.rescaleX(xScale)(d.x))
            .attr("cy", d => d3.event.transform.rescaleY(yScaleWater)(( d.y) * lassoMultiplier));

            d3.select(".line-water").selectAll("circle")
                .attr("cx", d => d3.event.transform.rescaleX(xScale)(d.x))
                .attr("cy", d => d3.event.transform.rescaleY(yScaleWater)( d.y));

            const updatedLineWater = d3.line()
                .curve(d3.curveStepBefore)
                .x(d => (d3.event.transform.rescaleX(xScale)(d.x)))
                .y(d => d3.event.transform.rescaleY(yScaleWater)( d.y));

            d3.select(".line-water")
                .select("path")
                .attr("d", updatedLineWater);
            yScaleWaterLasso.domain(d3.event.transform.rescaleY(yScaleWater).domain()); 
            //Water End
        }
        
        function zoomPanWaterOnlyOnRect(xScaleToUSe,yScaleToUSeWater,yScaleToUSeOil,yScaleToUSeGas){
            //Water Start
            axisGXAxis.call(xAxis.scale(xScaleToUSe));
            xScaleZoom=xScaleToUSe;
            yScaleWaterZoom=yScaleToUSeWater;
            xScaleLasso.domain(xScaleToUSe.domain());
            axisGWater.call(yAxisWater.scale(yScaleToUSeWater));
            noteLabelsWater.forEach(notes=>{
                const xPoint=xScaleToUSe(notes.x);
                const yPoint=yScaleToUSeWater(notes.y);
                fixedPositionOfNote(notes.noteReact,notes.textNode,xPoint,yPoint);
            });
            d3.select(".daily-data-container").selectAll(".circle-daily-water")
                .attr("cx", d => xScaleToUSe(d.x))
                .attr("cy", d => yScaleToUSeWater( d.y));
            d3.select(".lasso-selected-container").selectAll(".lasso-selected-water")
            .attr("cx", d => xScaleToUSe(d.x))
            .attr("cy", d => yScaleToUSeWater(( d.y) * lassoMultiplier));

            d3.select(".line-water").selectAll("circle")
                .attr("cx", d => xScaleToUSe(d.x))
                .attr("cy", d => yScaleToUSeWater( d.y));

            const updatedLineWater = d3.line()
                .curve(d3.curveStepBefore)
                .x(d => (xScaleToUSe(d.x)))
                .y(d => yScaleToUSeWater( d.y));

            d3.select(".line-water")
                .select("path")
                .attr("d", updatedLineWater);
            yScaleWaterLasso.domain(yScaleToUSeWater.domain()); 
            //Water End

            //Oil start
            axisGOil.call(yAxisOil.scale(yScaleToUSeOil));
                    
            noteLabelsOil.forEach(notes=>{
                const xPoint=xScaleToUSe(notes.x);
                const yPoint=yScaleToUSeOil(notes.y);
                fixedPositionOfNote(notes.noteReact,notes.textNode,xPoint,yPoint);
            });
            yScaleOilZoom=yScaleToUSeOil;
            d3.select(".daily-data-container").selectAll(".circle-daily-oil")
                .attr("cx", d => xScaleToUSe(d.x))
                .attr("cy", d => yScaleToUSeOil( d.y));

            d3.select(".lasso-selected-container").selectAll(".lasso-selected-oil")
            .attr("cx", d => xScaleToUSe(d.x))
            .attr("cy", d => yScaleToUSeOil(( d.y) * lassoMultiplier));

            d3.select(".line-oil").selectAll("circle")
                .attr("cx", d => xScaleToUSe(d.x))
                .attr("cy", d => yScaleToUSeOil( d.y));

            const updatedLineOil = d3.line()
                .curve(d3.curveStepBefore)
                .x(d => (xScaleToUSe(d.x)))
                .y(d => yScaleToUSeOil( d.y));

            d3.select(".line-oil")
                .select("path")
                .attr("d", updatedLineOil);

            yScaleOilLasso.domain(yScaleToUSeOil.domain()); 
            //Oil End

            //GAS Start
            axisGGas.call(yAxisGas.scale(yScaleToUSeGas));
            noteLabelsGas.forEach(notes=>{
                const xPoint=xScaleToUSe(notes.x);
                const yPoint=yScaleToUSeGas(notes.y);
                fixedPositionOfNote(notes.noteReact,notes.textNode,xPoint,yPoint);
            });
            yScaleGasZoom=yScaleToUSeGas;
            d3.select(".daily-data-container").selectAll(".circle-daily-gas")
                .attr("cx", d => xScaleToUSe(d.x))
                .attr("cy", d => yScaleToUSeGas( d.y));
            
            d3.select(".lasso-selected-container").selectAll(".lasso-selected-gas")
            .attr("cx", d => xScaleToUSe(d.x))
            .attr("cy", d => yScaleToUSeGas(( d.y) * lassoMultiplier));
            d3.select(".line-gas").selectAll("circle")
                .attr("cx", d => xScaleToUSe(d.x))
                .attr("cy", d => yScaleToUSeGas( d.y));

            const updatedLineGas = d3.line()
                .curve(d3.curveStepBefore)
                .x(d => (xScaleToUSe(d.x)))
                .y(d => yScaleToUSeGas( d.y));

            d3.select(".line-gas")
                .select("path")
                .attr("d", updatedLineGas);

            yScaleGasLasso.domain(yScaleToUSeGas.domain()); 
                // GAS End
        }
        
        // document.addEventListener("DOMContentLoaded", function(event) { 
        //     document.addEventListener("keydown",event=>{
        //          console.log("keydown:",event.ctrlKey);
        //      })
        //      document.addEventListener("keyup",event=>{
        //          console.log("keyup:",event.ctrlKey);
        //      })
        // });
       

        
        
           
        //CBT:Pan Feature on each Y Axis End
        function drpFeatures_Changed() {
            // lassoEndSelectionG.html('');
            if ($("#drpFeatures").val() == "zoom") {
                lasso_area.on(".dragstart", null);
                lasso_area.on(".drag", null);
                lasso_area.on(".dragend", null);
                zoom_area.style("pointer-events", "all");
                zoom_area.call(zoom);   
            } else {
                zoom_area.on('.zoom', null);
                zoom_area.style("pointer-events", "none");
                svgForLines.call(lasso);
                lasso.items(d3.selectAll("circle"));
            }
        }

        drpFeatures_Changed();

        
    </script>
</body>

</html>