<html>

<head>
    <style type="text/css">
        .cls-drp-feature {
            width: 150px;
            height: auto;
            float: right;
            padding: 5px;
            font-size: 12px;
            color: #000;
            position: absolute;
            right: 80px;
        }

        .line-rect {
            margin-right: 5px;
            width: 20px;
            height: 3px;
            background-color: red;
            display: inline-block;
        }

        .legend-container {
            display: flex;
            align-items: center;
        }

        #chart,
        .cls-drp-feature {
            display: inline-block;
        }

        .y-axis-water path {
            stroke: transparent;
        }

        .y-axis-gas path,
        .y-axis-oil path,
        .x-axis path {
            stroke: #bbb;
        }

        .y-axis-oil .tick line,
        .y-axis-gas .tick line,
        .y-axis-water .tick line,
        .x-axis .tick line {
            stroke: #bbb;
        }


        .axis-label-water,
        .axis-label-gas,
        .axis-label-oil,
        .axis-label-xaxis {
            fill: #555;
            font-size: 15px;
        }

        .axis-label-gas {
            text-anchor: end;
        }

        .axis-label-xaxis {
            text-anchor: start;
        }

        .line-water path,
        .line-oil path,
        .line-gas path {
            fill: none;
        }


        .lasso path {
            stroke: rgb(80, 80, 80);
            stroke-width: 2px;
        }

        .lasso .drawn {
            fill-opacity: .05;
        }

        .lasso .loop_close {
            fill: none;
            stroke-dasharray: 4, 4;
        }

        .lasso .origin {
            fill: #3399FF;
            fill-opacity: .5;
        }

        .not_possible {
            fill: rgb(200, 200, 200);
        }

        .possible {
            fill: #EC888C;
        }

        #chart {
            position: relative;
        }

        .tooltip-table-row {
            font-size: var(--body-text-size);
            color: #808080;

        }

        .tooltip-table-row .header {
            font-weight: var(--bold-font-weight);
        }

        .custom-tooltip {
            display: inline-block;
            height: auto;
            width: auto;
            position: absolute;
            z-index: 9999;
            background: white;
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #ccc;
            pointer-events: none;

        }

        .rectangle-container {
            position: absolute;
            display: flex;
            justify-content: center;
            width: 100%;
            left: 0px;
        }

        .rectangle-div {
            width: 20px;
            height: 20px;
            background: white;
            transform: rotate(45deg);
            transform: rotate(45deg);
            border-bottom: 1px solid #ccc;
            border-right: 1px solid #ccc;
        }

        .zoom-select-rect {
            fill: #ccc;
            fill-opacity: 0.5;
            stroke: #ccc;
            stroke-width: 2px;
            pointer-events: none;
        }
        .svg-slider-triangle path{
                fill: #ccc;
                cursor: move;
        }
        .triangle-text{
            text-anchor: middle;
            font-size: 12px;
            transform: translate(0px, -3px);
        }
        .triangle-line{
            stroke: rgba(0,0,0,0.5);
            stroke-width: 1px;
            stroke-dasharray: 5px;
        }
    </style>
</head>

<body>
    <div class="text-center">
        <div id="chart" oncontextmenu="return false;"></div>
        <div class="cls-drp-feature">
            <div class="legend">
                <div class='legend-container'>
                    <div class="line-rect" style="background: steelblue;"></div><span class="text-label">Monthly
                        Oil</span>
                </div>
                <div class='legend-container'>
                    <div class="line-rect" style="background: green;"></div><span class="text-label">Monthly Gas</span>
                </div>
                <div class='legend-container'>
                    <div class="line-rect" style="background: #da4545;"></div><span class="text-label">Monthly
                        Water</span>
                </div>
            </div>
            <br />
            <div class="major-gridline">
                <span class="lable-dropdown">Major Gridline:</span>
                <select id='majorGridlineData'>
                    <option value='Default' selected>Default</option>
                    <option value='Dotted'>Dotted</option>
                    <option value='Dashed'>Dashed</option>
                </select>
            </div>
            <br />
            <div class="minor-gridline">
                <span class="lable-dropdown">Minor Gridline:</span>
                <select id='minorGridlineData'>
                    <option value='Default' selected>Default</option>
                    <option value='Dotted'>Dotted</option>
                    <option value='Dashed'>Dashed</option>
                </select>
            </div>
            <br />
            <div class='checkboxes'>
                <input type="checkbox" id='chbxWaterGrdLine' />
                <span>Water Gridline</span>
            </div>
            <div class='checkboxes'>
                <input type="checkbox" id='chbxOilGrdLine' checked />
                <span>Oil Gridline</span>
            </div>
            <div class='checkboxes'>
                <input type="checkbox" id='chbxGasGrdLine' />
                <span>Gas Gridline</span>
            </div>
        </div>
    </div>
    <script src="d3.v5.min.js"></script>
    <script src="jquery.js"></script>
    <script src="data.js"></script>
    <script src="d3-lasso.min.js"></script>
    <script>
        let majorGridLineData = null;
        let minorGridLineData = null;
        let isWaterGridLineEnabled = false;
        let isOilGridLineEnabled = true;
        let isGasGridLineEnabled = false;
        const dottedStyleValue = '1px';
        const dashedStyleValue = '5px';
        const solidStyleValue = '0px';
        const mainDivRef = "#chart";
        const margin = {
            left: 80,
            right: 80,
            top: 40,
            bottom: 50
        };
        const heightOfTriangle=20;
        const widthOfTriangle=30;
        const triangleTextDisplayFromat="%Y-%b-%d";
        const width = 1000;
        const height = 600;
        const widthForWaterOilYAxis = margin.left * 2;
        const chartWidth = width - (widthForWaterOilYAxis + margin.right);
        const chartHeight = height - (margin.top + margin.bottom);
        const lassoMultiplier = 5;
        const widthForMiddleAreaWithWaterOilYAxis = chartWidth + widthForWaterOilYAxis;
        const heightForMiddleAreaWithMarginBottom = height - margin.top;

        const updateMajorGridLineStokeDashedStyle = () => {
            let styleValue = solidStyleValue;
            if (majorGridLineData == 'Dotted') {
                styleValue = dottedStyleValue;
            } else if (majorGridLineData == 'Dashed') {
                styleValue = dashedStyleValue;
            } else {
                styleValue = solidStyleValue;
            }
            d3.select(".y-axis-water").selectAll(".tick").nodes().forEach((element, data1) => {
                const textValue = d3.select(element).select("text").text();
                if (textValue != '') {
                    d3.select(element).select("line").style("stroke-dasharray", styleValue);
                    d3.select(element).select(".extra-yaxis-water-tick-line").style("stroke-dasharray", styleValue);
                }
                if (isWaterGridLineEnabled == true) {
                    d3.select(".y-axis-water").selectAll(".tick").nodes().forEach((element, data1) => {
                        d3.select(element).select("line").attr("x1", margin.left);
                        d3.select(element).select("text").attr("x", -9);
                        d3.select(element).selectAll(".extra-yaxis-water-tick-line").remove();
                        d3.select(element).append("line").attr("class", 'extra-yaxis-water-tick-line').attr("x1", 0).attr("x2", -6);
                    })
                }
            })
            d3.select(".y-axis-oil").selectAll(".tick").nodes().forEach((element, data1) => {
                const textValue = d3.select(element).select("text").text();
                if (textValue != '') {
                    d3.select(element).select("line").style("stroke-dasharray", styleValue);
                }
            })
            d3.select(".y-axis-gas").selectAll(".tick").nodes().forEach((element, data1) => {
                const textValue = d3.select(element).select("text").text();
                if (textValue != '') {
                    d3.select(element).select("line").style("stroke-dasharray", styleValue);
                }
            })
        }
        function getTranslation(transform) {
            var g = document.createElementNS("http://www.w3.org/2000/svg", "g");
            g.setAttributeNS(null, "transform", transform);
            var matrix = g.transform.baseVal.consolidate().matrix;
            return [matrix.e, matrix.f];
        }
        const updateMinorGridLineStokeDashedStyle = () => {
            let styleValue = solidStyleValue;
            if (minorGridLineData == 'Dotted') {
                styleValue = dottedStyleValue;
            } else if (minorGridLineData == 'Dashed') {
                styleValue = dashedStyleValue;
            } else {
                styleValue = solidStyleValue;
            }
            d3.select(".y-axis-water").selectAll(".tick").nodes().forEach((element, data1) => {
                const textValue = d3.select(element).select("text").text();
                if (textValue == '') {
                    d3.select(element).select("line").style("stroke-dasharray", styleValue);
                    d3.select(element).select(".extra-yaxis-water-tick-line").style("stroke-dasharray", styleValue);
                }
            })
            d3.select(".y-axis-oil").selectAll(".tick").nodes().forEach((element, data1) => {
                const textValue = d3.select(element).select("text").text();
                if (textValue == '') {
                    d3.select(element).select("line").style("stroke-dasharray", styleValue);
                }
            })
            d3.select(".y-axis-gas").selectAll(".tick").nodes().forEach((element, data1) => {
                const textValue = d3.select(element).select("text").text();
                if (textValue == '') {
                    d3.select(element).select("line").style("stroke-dasharray", styleValue);
                }
            })
        }
        $(document).ready(() => {
            $("#majorGridlineData").on("change", () => {
                majorGridLineData = document.getElementById("majorGridlineData").value;
                updateMajorGridLineStokeDashedStyle();
            });
            $("#minorGridlineData").on("change", () => {
                minorGridLineData = document.getElementById("minorGridlineData").value;
                updateMinorGridLineStokeDashedStyle();
            });
            $("#chbxWaterGrdLine").on("change", () => {
                isWaterGridLineEnabled = document.getElementById("chbxWaterGrdLine").checked;
                console.log("isWaterGridLineEnabled:", isWaterGridLineEnabled);
                if (isWaterGridLineEnabled == true) {
                    axisGWater.call(yAxisWater.tickSize(-1 * chartWidth - margin.left));
                    d3.select(".y-axis-water").selectAll(".tick").nodes().forEach((element, data1) => {
                        d3.select(element).select("line").attr("x1", margin.left);
                        d3.select(element).select("text").attr("x", -9);
                        d3.select(element).selectAll(".extra-yaxis-water-tick-line").remove();
                        d3.select(element).append("line").attr("class", 'extra-yaxis-water-tick-line').attr("x1", 0).attr("x2", -6);
                    })
                }
                else {
                    d3.select(".y-axis-water").selectAll(".tick").nodes().forEach((element, data1) => {
                        d3.select(element).select("line").attr("x1", 0);
                        d3.select(element).selectAll(".extra-yaxis-water-tick-line").remove();
                    })
                    axisGWater.call(yAxisWater.tickSize(6));
                }
            });
            $("#chbxOilGrdLine").on("change", () => {
                isOilGridLineEnabled = document.getElementById("chbxOilGrdLine").checked;
                console.log("isOilGridLineEnabled:", isOilGridLineEnabled);
                const calculatedTickSize = getCalculatedTickSize();
                if (isOilGridLineEnabled == true)
                    axisGOil.call(yAxisOil.tickSize(-1 * chartWidth).ticks(calculatedTickSize, ".0f"));
                else
                    axisGOil.call(yAxisOil.tickSize(6).ticks(calculatedTickSize, ".0f"));
            });
            $("#chbxGasGrdLine").on("change", () => {
                isGasGridLineEnabled = document.getElementById("chbxGasGrdLine").checked;
                console.log("isGasGridLineEnabled:", isGasGridLineEnabled);
                if (isGasGridLineEnabled == true)
                    axisGGas.call(yAxisGas.tickSize(-1 * chartWidth));
                else
                    axisGGas.call(yAxisGas.tickSize(6));
            });
        });




        console.log(widthForWaterOilYAxis, widthForMiddleAreaWithWaterOilYAxis, chartHeight);

        let monthlyData = chartData;
        const array_oil = [];
        const colors = {
            oil: 'steelblue',
            gas: 'green',
            water: '#da4545'
        };

        const array_gas = [];
        const array_water = [];
        const allValues = [];
        const allDates = [];

        const parseTime = d3.timeParse("%m%d%Y");

        monthlyData = monthlyData.sort((a, b) => {
            return new Date(parseTime(a.DisplayDate)).getTime() - new Date(parseTime(b.DisplayDate)).getTime();
        })

        for (let i = 0; i < monthlyData.length; i++) {
            let oil = {};
            oil.x = parseTime(monthlyData[i].DisplayDate);
            oil.y = monthlyData[i].Oil;
            oil.section = "Oil";
            oil.colors = colors.oil;
            if (monthlyData[i].Oil > 0) {
                allValues.push(monthlyData[i].Oil);
                allDates.push(oil.x);
                array_oil.push(oil);
            }

            let gas = {};
            gas.x = parseTime(monthlyData[i].DisplayDate);
            //gas.x = (i + 1);
            gas.y = monthlyData[i].Gas;
            gas.section = "Gas";
            gas.colors = colors.gas;
            if (monthlyData[i].Gas > 0) {
                allValues.push(monthlyData[i].Gas);
                allDates.push(gas.x);
                array_gas.push(gas);
            }

            let water = {};
            water.x = parseTime(monthlyData[i].DisplayDate);
            //water.x = (i + 1);
            water.y = monthlyData[i].Water;
            water.section = "Water";
            water.colors = colors.water;
            if (monthlyData[i].Water > 0) {
                allValues.push(monthlyData[i].Water);
                allDates.push(water.x);
                array_water.push(water);
            }
        }

        const data = [];
        data.push(array_oil);
        data.push(array_gas);
        data.push(array_water);

        const oilMinMax = d3.extent(array_oil.map(d => d.y));
        const gasMinMax = d3.extent(array_gas.map(d => d.y));
        const waterMinMax = d3.extent(array_water.map(d => d.y));
        const overallMinMax = d3.extent([...oilMinMax, ...gasMinMax, ...waterMinMax]);

        const waterOilMinMax = d3.extent([...oilMinMax, ...waterMinMax])
        const minDate = Math.min.apply(null, allDates);
        const maxDate = Math.max.apply(null, allDates);
        
        let xScale = d3.scaleTime()
            .domain([minDate, maxDate])
            .range([0, chartWidth]);
        let xScaleZoom = xScale;

        const noteLabelsWater = [];
        const noteLabelsGas = [];
        const noteLabelsOil = [];
        let yScaleWaterZoom = null;
        let yScaleWater = d3.scaleLog()
            .domain([waterOilMinMax[0], waterOilMinMax[1]])
            .range([chartHeight, 0]);

        let yScaleOilZoom = null;
        let yScaleOil = d3.scaleLog()
            .domain([waterOilMinMax[0], waterOilMinMax[1]])
            .range([chartHeight, 0]);

        let yScaleGasZoom = null;
        let yScaleGas = d3.scaleLog()
            .domain([gasMinMax[0], gasMinMax[1]])
            .range([chartHeight, 0]);

        let xScaleLasso = d3.scaleTime()
            .domain([minDate, maxDate])
            .range([0, chartWidth]);
        let yScaleGasLasso = d3.scaleLog()
            .domain([gasMinMax[0], gasMinMax[1]])
            .range([chartHeight, 0]);;
        let yScaleOilLasso = d3.scaleLog()
            .domain([waterOilMinMax[0], waterOilMinMax[1]])
            .range([chartHeight, 0]);;
        let yScaleWaterLasso = d3.scaleLog()
            .domain([waterOilMinMax[0], waterOilMinMax[1]])
            .range([chartHeight, 0]);;


        const svg = d3.select(mainDivRef)
            .append("svg")
            .attr("width", width)
            .attr("height", height);

        const xAxis = d3.axisBottom(xScale);


        const yAxisWater = d3.axisLeft(yScaleWater);
        const yAxisOil = d3.axisLeft(yScaleOil);
        const yAxisGas = d3.axisRight(yScaleGas);


        const axisGWater = svg.append("g")
            .attr("class", "y-axis-water");

        axisGWater.attr("transform", `translate(${margin.left},${margin.top})`)
            .call(yAxisWater.ticks(7, ".0f"));

        axisGWater
            .append("text")
            .attr("class", "axis-label-water")
            .attr("transform", "rotate(-90)")
            .attr("y", -1 * (margin.left * 0.7))
            .attr("x", -1 * ((height / 2) * 0.8))
            .text('Water (BBL/d)');



        const axisGOil = svg.append("g")
            .attr("class", "y-axis-oil");

        axisGOil.attr("transform", `translate(${widthForWaterOilYAxis},${margin.top})`)
            .call(yAxisOil.ticks(7, ".0f").tickSize(-1 * chartWidth));

        axisGOil
            .append("text")
            .attr("class", "axis-label-oil")
            .attr("transform", "rotate(-90)")
            .attr("y", -1 * (margin.left * 0.7))
            .attr("x", -1 * ((height / 2) * 0.8))
            .text('Oil (BBL/d)');

        const axisGGas = svg.append("g")
            .attr("class", "y-axis-gas");

        axisGGas.attr("transform", `translate(${width - margin.right},${margin.top})`)
            .call(yAxisGas.ticks(7, ".0f"));

        axisGGas
            .append("text")
            .attr("class", "axis-label-gas")
            .attr("transform", "rotate(-90)")
            .attr("y", (margin.left * 0.8))
            .attr("x", -1 * ((height / 2) * 0.8))
            .text('Gas (MCF/d)');

        const axisGXAxis = svg.append("g")
            .attr("class", "x-axis")
            .attr("transform", `translate(${(widthForWaterOilYAxis)},${(height - (margin.bottom))})`);

        axisGXAxis.call(xAxis);

        axisGXAxis.append("text")
            .attr("class", "axis-label-xaxis")
            .attr("y", margin.bottom * 0.8)
            .attr("x", ((width) / 2) - (widthForWaterOilYAxis))
            .text('Date');


        const lineWater = d3.line()
            .curve(d3.curveStepBefore)
            .x(d => xScale(d.x))
            .y(d => yScaleWater(d.y));

        const lineOil = d3.line()
            .curve(d3.curveStepBefore)
            .x(d => xScale(d.x))
            .y(d => yScaleOil(d.y));

        const lineGas = d3.line()
            .curve(d3.curveStepBefore)
            .x(d => xScale(d.x))
            .y(d => yScaleGas(d.y));

        const circleRadius = 3;
        const selectedLassoRect = 'orange';

        var clip = svg.append("defs").append("SVG:clipPath")
            .attr("id", "clip")
            .append("SVG:rect")
            .attr("width", chartWidth)
            .attr("height", chartHeight)
            .attr("x", 0)
            .attr("y", 0);

        const svgForLines = svg
            .append("g")
            .attr("class", "svg-with-line")
            .attr("clip-path", "url(#clip)")
            .attr("transform", `translate(${widthForWaterOilYAxis},${margin.top})`);
        //CBT:slider start
        function updateTriangleText(){
            console.log("xScaleZoom:",xScaleZoom.domain(),"\txScale:",xScale.domain());
            const rightTringleNode=d3.select('.svg-slider-right').node();
            const leftTringleNode=d3.select('.svg-slider-left').node();
            const rightTriangleXValue=getTranslation(rightTringleNode.getAttribute("transform"))[0];
            const leftTriangleXValue=getTranslation(leftTringleNode.getAttribute("transform"))[0]; 
            d3.select(".right-triangle-text").text(d3.timeFormat(triangleTextDisplayFromat)(xScaleZoom.invert(rightTriangleXValue)));
            d3.select(".left-triangle-text").text(d3.timeFormat(triangleTextDisplayFromat)(xScaleZoom.invert(leftTriangleXValue)));
        }
        var lineGenerator = d3.line();
        let x1=-(widthOfTriangle*0.5),x2=widthOfTriangle/2,x3=0;
        var pointsLeftTriangle = [
            [x1, 0],
            [x2, 0],
            [x3, heightOfTriangle],
            [x1, 0]
        ];
        var pointsRightTriangle = [
            [x1, 0],
            [x2, 0],
            [x3, heightOfTriangle],
            [x1, 0]
        ];
        let xLftLinePoint=0,y1LeftLinePoint=heightOfTriangle,y2LeftLinePoint=heightOfTriangle+chartHeight+2;
        var pointsLeftTriangleLine = [
            [xLftLinePoint, y1LeftLinePoint],
            [xLftLinePoint, y2LeftLinePoint],
        ];
        xLftLinePoint=x3,y1LeftLinePoint=heightOfTriangle,y2LeftLinePoint=heightOfTriangle+chartHeight+2;
        var pointsRightTriangleLine = [
            [xLftLinePoint, y1LeftLinePoint],
            [xLftLinePoint, y2LeftLinePoint],
        ];
        var leftTrianglePath = lineGenerator(pointsLeftTriangle);
        var leftTriangleLine = lineGenerator(pointsLeftTriangleLine);
        var rightTrianglePath = lineGenerator(pointsRightTriangle);
        var rightTriangleLine = lineGenerator(pointsRightTriangleLine);
        const sliderIconContainer = svg
            .append("g")
            .attr("class", "svg-slider-container")
            .attr("transform", `translate(${widthForWaterOilYAxis},${margin.top - heightOfTriangle})`);
        const leftTriangleG=sliderIconContainer.append("g")
        .attr("transform",`translate(0,0)`)
        .attr("class", "svg-slider-left svg-slider-triangle").call(d3.drag()
        .on("drag", (d)=>{dragged(d,'leftTriangle')}));
        
        leftTriangleG.append('path')
        .attr("d",leftTrianglePath);
        leftTriangleG.append('path')
        .attr("class",'left-triangle-line triangle-line')
        .attr("d",leftTriangleLine);
        leftTriangleG.append("text")
        .attr("class",'left-triangle-text triangle-text')
        .text(d3.timeFormat(triangleTextDisplayFromat)(xScaleZoom.invert(0)));

        const rightTriangleG=sliderIconContainer.append("g")
        .attr("transform",`translate(${chartWidth},0)`)
        .attr("class", "svg-slider-right svg-slider-triangle").call(d3.drag()
        .on("drag", (d)=>{dragged(d,'rightTriangle')}));

        rightTriangleG.append('path')
        .attr("d",rightTrianglePath);
        rightTriangleG.append('path')
        .attr("class",'right-triangle-line triangle-line')
        .attr("d",rightTriangleLine);
        rightTriangleG.append("text")
        .attr("class",'right-triangle-text triangle-text')
        .text(d3.timeFormat(triangleTextDisplayFromat)(xScaleZoom.invert(chartWidth)));

        const dragged=(d,sliderRef)=>{
            console.log("xScaleZoom:",xScaleZoom.domain(),"\txScale:",xScaleZoom.domain());
            const xValue=d3.event.x;
            const rightTringleNode=d3.select('.svg-slider-right').node();
            const leftTringleNode=d3.select('.svg-slider-left').node();
            const leftTringleTextNode=d3.select('.left-triangle-text').node().getBBox();
            const rightTringleTextNode=d3.select('.right-triangle-text').node().getBBox();
            const rightTriangleXValue=getTranslation(rightTringleNode.getAttribute("transform"))[0];
            const leftTriangleXValue=getTranslation(leftTringleNode.getAttribute("transform"))[0];
            //CBT:Left Triangle 
            if(sliderRef=='leftTriangle' && xValue>-1 && xValue<((chartWidth+1)) && xValue<rightTriangleXValue){
                d3.select(".svg-slider-left").attr("transform",`translate(${xValue},0)`);
                d3.select(".left-triangle-text").text(d3.timeFormat(triangleTextDisplayFromat)(xScaleZoom.invert(xValue)));
                const overlapDifference=(leftTriangleXValue+(leftTringleTextNode.width/2))-(rightTriangleXValue-(rightTringleTextNode.width/2));
                if(overlapDifference>0){
                    d3.select('.left-triangle-text').attr("x",-1*(leftTringleTextNode.width));
                }else{
                    d3.select('.left-triangle-text').attr("x",0);
                }
            }else if(sliderRef=='rightTriangle' && xValue>-1 && xValue<((chartWidth+1)) && xValue>leftTriangleXValue){
                d3.select(".svg-slider-right").attr("transform",`translate(${xValue},0)`);
                d3.select(".right-triangle-text").text(d3.timeFormat(triangleTextDisplayFromat)(xScaleZoom.invert(xValue)));
                const overlapDifference=(rightTriangleXValue-(rightTringleTextNode.width/2))-(leftTriangleXValue+(leftTringleTextNode.width/2));
                if(overlapDifference<0){
                    d3.select('.right-triangle-text').attr("x",(rightTringleTextNode.width));
                }else{
                    d3.select('.right-triangle-text').attr("x",0);
                }
            }
            console.log("LeftSlider :",d3.select('.left-triangle-text').text());
            console.log("RightSlider :",d3.select('.right-triangle-text').text());
        }
        //CBT:slider End

        const lineWaterG = svgForLines.append("g")
            .attr("class", 'line-water')
            .attr("transform", `translate(0,0)`);

        lineWaterG
            .append("path")
            .data([array_water])
            .attr("d", lineWater)
            .style("stroke", d => d[0].colors);

        lineWaterG.selectAll("circle")
            .data(array_water)
            .enter()
            .append("circle")
            .datum(d => d)
            .attr("data", d => JSON.stringify(d))
            .attr("cx", d => xScale(d.x))
            .attr("cy", d => yScaleWater(d.y))
            .attr("r", circleRadius)
            .style("fill", d => d.colors);


        const lineOilG = svgForLines.append("g")
            .attr("class", 'line-oil')
            .attr("transform", `translate(0,0)`);

        lineOilG
            .append("path")
            .data([array_oil])
            .attr("d", lineOil)
            .style("stroke", d => d[0].colors);

        lineOilG.selectAll("circle")
            .data(array_oil)
            .enter()
            .append("circle")
            .datum(d => d)
            .attr("data", d => JSON.stringify(d))
            .attr("cx", d => xScale(d.x))
            .attr("cy", d => yScaleOil(d.y))
            .attr("r", circleRadius)
            .style("fill", d => d.colors);


        const lineGasG = svgForLines.append("g")
            .attr("class", 'line-gas')
            .attr("transform", `translate(0,0)`);

        lineGasG
            .append("path")
            .data([array_gas])
            .attr("d", lineGas)
            .style("stroke", d => d[0].colors);

        lineGasG.selectAll("circle")
            .data(array_gas)
            .enter()
            .append("circle")
            .datum(d => d)
            .attr("data", d => JSON.stringify(d))
            .attr("cx", d => xScale(d.x))
            .attr("cy", d => yScaleGas(d.y))
            .attr("r", circleRadius)
            .style("fill", d => d.colors);


        const lassoEndSelectionG = svg.append("g")
            .attr("class", "lasso-selected-container")
            .attr("transform", `translate(${widthForWaterOilYAxis},${margin.top})`);

        //CBT:Daily Data Plotting start
        const dailyDataG = svgForLines.append("g")
            .attr("class", "daily-data-container")
            .attr("transform", `translate(0,0)`);

        const array_gas_daily = [];
        const array_water_daily = [];
        const array_oil_daily = []

        for (let i = 0; i < dailyData.length; i++) {
            let oil = {};
            oil.x = parseTime(dailyData[i].DisplayDate);
            oil.y = dailyData[i].Oil;
            oil.section = "Oil";
            oil.colors = colors.oil;
            if (dailyData[i].Oil > 0)
                array_oil_daily.push(oil);

            let gas = {};
            gas.x = parseTime(dailyData[i].DisplayDate);
            gas.y = dailyData[i].Gas;
            gas.section = "Gas";
            gas.colors = colors.gas;
            if (dailyData[i].gas > 0)
                array_gas_daily.push(gas);

            let water = {};
            water.x = parseTime(dailyData[i].DisplayDate);
            water.y = dailyData[i].Water;
            water.section = "Water";
            water.colors = colors.water;
            if (dailyData[i].water > 0)
                array_water_daily.push(water);
        }

        const daily_data_all = [...array_gas_daily, ...array_oil_daily, ...array_water_daily];

        dailyDataG.selectAll("circle")
            .data(daily_data_all)
            .enter()
            .append("circle")
            .datum(d => d)
            .attr("cx", d => xScale(d.x))
            .attr("cy", d => {
                if (d.section.toLowerCase() == 'oil')
                    return yScaleOil(d.y)
                else if (d.section.toLowerCase() == 'gas')
                    return yScaleGas(d.y)
                else if (d.section.toLowerCase() == 'water')
                    return yScaleWater(d.y)
            })
            .attr("class", d => {
                if (d.section.toLowerCase() == 'oil')
                    return "circle-daily-oil"
                else if (d.section.toLowerCase() == 'gas')
                    return "circle-daily-gas"
                else if (d.section.toLowerCase() == 'water')
                    return "circle-daily-water"
            })
            .attr("r", circleRadius)
            .style("fill", d => d.colors);

        //CBT:Daily Data Plotting end
        var zoomdefination = d3.zoom()
            .scaleExtent([-10, 20])  // This control how much you can unzoom (x0.5) and zoom (x20)
            .extent([[0, 0], [chartWidth, chartHeight]])
            .filter(function () {
                console.log(d3.event.button, d3.event.type);
                return (d3.event.button == 1 || d3.event.button == 2 || (d3.event.type == 'wheel' && d3.event.button == 0))
            })
            .on("zoom", updateChart)
            .on("end", updateChartZoomEnd)
            .on("start", updateChartZoomStart);

        let zoom_area = svg
            .append("rect")
            .attr("class", "zoom-area-rect")
            .attr("id", "zoom-area-rect-id")
            .attr("transform", `translate(0,${margin.top})`)
            .attr("width", width)
            .attr("height", height - margin.top)
            .style("fill", 'none')
            .style("pointer-events", "all")
            .on("dblclick", onLassoDoubleReactClick)
            .on("click", onLassoReactClick)
            .on("mousemove", onLassoReactMouseMove)
            .on("mouseout", onLassoReactMouseOut)
            .on("mousedown", onLassoReactMouseDown)
            .on("mouseup", onLassoReactMouseUp);

        zoom_area.call(zoomdefination);

        const box_for_select_area = svg
            .append("g")
            .attr("class", "box-for-select-area")
            .attr("transform", `translate(0,${margin.top})`);

        const zoom_select_rect = box_for_select_area
            .append("rect")
            .attr("class", "zoom-select-rect");


        function onLassoReactMouseMove(event) {
            const mousePoint = d3.mouse(this);
            if (d3.event.ctrlKey == true) {
                const startX = zoom_select_rect.attr("x");
                const startY = zoom_select_rect.attr("y");
                if (startX != null && startX != '' && startY != null && startY != '') {
                    zoom_select_rect
                        .attr("width", Math.abs(startX - mousePoint[0]))
                        .attr("height", Math.abs(startY - mousePoint[1]));
                }
                return;//Return when cntl key was pressed and mouse move
            }
            if (d3.event.altKey == true) {
                d3.selectAll(".lasso").remove();
                zoom_area.on('.zoom', null);
                zoom_area.style("pointer-events", "none");
                svgForLines.call(lasso);
                lasso.items(d3.selectAll("circle"));
            }
            if ((mousePoint[0] < widthForWaterOilYAxis || mousePoint[0] > widthForMiddleAreaWithWaterOilYAxis || mousePoint[1] > chartHeight)) {
                return [];
            }
            const allSelectedPoints = calculateDataOnClick(this);
            // console.log("onLassoReactMouseMove",d3.event.ctrlKey);
            if (allSelectedPoints.length > 0) {
                // console.log(JSON.stringify(allSelectedPoints));
                let tooltipData = "";
                let topLeftPositionOfTooltip = { topPosition: 100, leftPosition: 100 };
                tooltipData = (
                    '<div className="tooltip-table">\
                            <div className="tooltip-table-row">\
                                <span className="header">Date:</span>\
                                <span>'+ d3.timeFormat("%Y-%m-%d")(new Date(allSelectedPoints[0].x)) + '</span>\
                            </div>\
                            <div className="tooltip-table-row">\
                                <span className="header">Section:</span>\
                                <span>'+ allSelectedPoints[0].section + '</span>\
                            </div>\
                            <div className="tooltip-table-row">\
                                <span className="header">Value:</span>\
                                <span>'+ allSelectedPoints[0].y + '</span>\
                            </div>\
                        </div>'
                );
                topLeftPositionOfTooltip = {
                    topPosition: d3.mouse(this)[1] + d3.select(this).node().getBoundingClientRect().top - circleRadius + window.scrollY,
                    leftPosition: d3.mouse(this)[0] + d3.select(this).node().getBoundingClientRect().left - (circleRadius * 2) + window.scrollX
                };
                callShowTooltip(topLeftPositionOfTooltip.topPosition, topLeftPositionOfTooltip.leftPosition, tooltipData, mainDivRef);
            } else {
                callHideTooltip(mainDivRef);
            }

        }
        function onLassoReactMouseOut(event) {
            // console.log("Event: Mouse Out:",d3.event.ctrlKey);
            callHideTooltip(mainDivRef);
        }

        function onLassoReactMouseDown(event) {
            // console.log("onLassoReactMouseDown",d3.event.ctrlKey);
            if (d3.event.ctrlKey == true) {
                const mousePoint = d3.mouse(this);
                zoom_select_rect
                    .attr("x", mousePoint[0])
                    .attr("y", mousePoint[1]);
            }
            if (d3.event.altKey == true) {
                d3.selectAll(".lasso").remove();
                zoom_area.on('.zoom', null);
                zoom_area.style("pointer-events", "none");
                svgForLines.call(lasso);
                lasso.items(d3.selectAll("circle"));
            }
        }
      

        function onLassoReactMouseUp(event) {
            // console.log("onLassoReactMouseUp",d3.event.ctrlKey);
            if (d3.event.ctrlKey) {
                const marginLeft = (widthForWaterOilYAxis);
                const startX = zoom_select_rect.attr("x");
                const startY = zoom_select_rect.attr("y");
                const widthOfRect = Math.abs(zoom_select_rect.attr("width")) + Math.abs(startX) - marginLeft;
                const heightOfRect = Math.abs(zoom_select_rect.attr("height")) + Math.abs(startY);
                // console.log("startX:",startX,"startY",startY,"widthOfRect",widthOfRect,"heightOfRect",heightOfRect);
                if (startX != null && startX != '' && startY != null && startY != '') {
                    // console.log("startX:",xScale.invert(startX-marginLeft),"startY",yScaleWater.invert(startY),"widthOfRect",xScale.invert(widthOfRect),"heightOfRect",yScaleWater.invert(heightOfRect));
                    const xScaleToUSe = xScaleZoom != null ? xScaleZoom : xScale;
                    const yScaleToUSeWater = yScaleWaterZoom != null ? yScaleWaterZoom : yScaleWater;
                    xScaleToUSe.domain([xScaleToUSe.invert(startX - marginLeft), xScaleToUSe.invert(widthOfRect)]);
                    yScaleToUSeWater.domain([yScaleToUSeWater.invert(heightOfRect), yScaleToUSeWater.invert(startY)]);
                    // console.log("yScaleToUSeWater:",yScaleToUSeWater.domain(),yScaleToUSeWater.range(),yScaleWater.range());
                    yScaleWater = yScaleToUSeWater;
                    xScale = xScaleToUSe;
                    updateTriangleText();
                    const yScaleToUSeOil = yScaleOilZoom != null ? yScaleOilZoom : yScaleOil;
                    yScaleToUSeOil.domain([yScaleToUSeOil.invert(heightOfRect), yScaleToUSeOil.invert(startY)]);
                    yScaleOil = yScaleToUSeOil;

                    const yScaleToUSeGas = yScaleGasZoom != null ? yScaleGasZoom : yScaleGas;
                    yScaleToUSeGas.domain([yScaleToUSeGas.invert(heightOfRect), yScaleToUSeGas.invert(startY)]);
                    yScaleGas = yScaleToUSeGas;

                    zoomPanWaterOnlyOnRect(xScaleToUSe, yScaleToUSeWater, yScaleToUSeOil, yScaleToUSeGas);
                }
            }
            zoom_area.style("pointer-events", "all");
            zoom_area.on('.zoom', null);
            zoom_area.call(zoomdefination);
            zoom_select_rect
                .attr("x", null)
                .attr("y", null)
                .attr("width", null)
                .attr("height", null);
            zoom_area.call(zoomdefination.transform, d3.zoomIdentity);
        }
        function onLassoDoubleReactClick() {

            var selection = document.getSelection();
            selection.removeAllRanges();
            xScale = d3.scaleTime()
                .domain([minDate, maxDate])
                .range([0, chartWidth]);

            yScaleWater = d3.scaleLog()
                .domain([waterOilMinMax[0], waterOilMinMax[1]])
                .range([chartHeight, 0]);

            yScaleOil = d3.scaleLog()
                .domain([waterOilMinMax[0], waterOilMinMax[1]])
                .range([chartHeight, 0]);

            yScaleGas = d3.scaleLog()
                .domain([gasMinMax[0], gasMinMax[1]])
                .range([chartHeight, 0]);

            xScaleLasso = d3.scaleTime()
                .domain([minDate, maxDate])
                .range([0, chartWidth]);

            yScaleGasLasso = d3.scaleLog()
                .domain([gasMinMax[0], gasMinMax[1]])
                .range([chartHeight, 0]);
            yScaleOilLasso = d3.scaleLog()
                .domain([waterOilMinMax[0], waterOilMinMax[1]])
                .range([chartHeight, 0]);
            yScaleWaterLasso = d3.scaleLog()
                .domain([waterOilMinMax[0], waterOilMinMax[1]])
                .range([chartHeight, 0]);

            yScaleWaterZoom = null;
            yScaleOilZoom = null;
            yScaleGasZoom = null;
            xScaleZoom = null;
            zoom_area.on('.zoom', null);
            zoom_area.style("pointer-events", "all");
            zoom_area.call(zoomdefination);
            zoom_area.call(zoomdefination.transform, d3.zoomIdentity);

        }
        function onLassoReactClick(event) {
            const mousePoint = d3.mouse(this);
            if (d3.event.ctrlKey == true)
                return;//Return when cntl key was pressed and mouse clicked
            if ((mousePoint[0] < widthForWaterOilYAxis || mousePoint[0] > widthForMiddleAreaWithWaterOilYAxis || mousePoint[1] > chartHeight)) {
                return;
            }
            const allSelectedPoints = calculateDataOnClick(this);
            // console.log("onLassoReactClick",d3.event.ctrlKey);
            if (allSelectedPoints.length > 0) {
                const labelValue = prompt("Enter Label Value to Be add");
                if (labelValue == null || labelValue.trim() == '')
                    return;
                let yScaleToUse = yScaleWaterZoom != null ? yScaleWaterZoom : yScaleWater;
                let yScaleToUseCopy = yScaleWater;
                if (allSelectedPoints[0].section == 'Gas') {
                    yScaleToUse = yScaleGasZoom != null ? yScaleGasZoom : yScaleGas;
                    yScaleToUseCopy = yScaleGas;
                } else if (allSelectedPoints[0].section == 'Oil') {
                    yScaleToUse = yScaleOilZoom != null ? yScaleOilZoom : yScaleOil;
                    yScaleToUseCopy = yScaleOil;
                }
                const xScaleToUSe = xScaleZoom != null ? xScaleZoom : xScale;
                const xPoint = xScaleToUSe(allSelectedPoints[0].x);
                const yPoint = yScaleToUse(allSelectedPoints[0].y);

                const noteReact = d3.select(".area-for-note")
                    .append("rect")
                    .style("fill", "white")
                    .style("stroke", "#ccc");

                const textNode = d3.select(".area-for-note")
                    .append("text")
                    .attr("dy", "0.35em")
                    .attr("text-anchor", "start")
                    .text(labelValue);
                fixedPositionOfNote(noteReact, textNode, xPoint, yPoint);
                if (allSelectedPoints[0].section == 'Water') {
                    noteLabelsWater.push({
                        noteReact: noteReact,
                        textNode: textNode,
                        x: allSelectedPoints[0].x,
                        y: allSelectedPoints[0].y,
                        yScaleToUse: yScaleToUseCopy,
                        xScaleToUSe: xScale
                    })
                } else if (allSelectedPoints[0].section == 'Gas') {
                    noteLabelsGas.push({
                        noteReact: noteReact,
                        textNode: textNode,
                        x: allSelectedPoints[0].x,
                        y: allSelectedPoints[0].y,
                        yScaleToUse: yScaleToUseCopy,
                        xScaleToUSe: xScale
                    })
                } else if (allSelectedPoints[0].section == 'Oil') {
                    noteLabelsOil.push({
                        noteReact: noteReact,
                        textNode: textNode,
                        x: allSelectedPoints[0].x,
                        y: allSelectedPoints[0].y,
                        yScaleToUse: yScaleToUseCopy,
                        xScaleToUSe: xScale
                    })
                }
            }
        }

        function fixedPositionOfNote(noteReact, textNode, xPoint, yPoint) {
            const textNodeSize = textNode.node().getBBox();
            const rectLeftPadding = 5;
            const rectTopPadding = 10;
            const extraSpaceToNote = 10;

            const textNodeYPosition = parseFloat(yPoint) + textNodeSize.width + extraSpaceToNote;
            textNode.attr("transform", `translate(${xPoint},${textNodeYPosition + (rectTopPadding / 2)}) rotate(270)`);
            noteReact.attr("width", textNodeSize.height + (rectLeftPadding * 2));
            noteReact.attr("height", textNodeSize.width + (rectTopPadding * 2));
            noteReact.attr("x", xPoint - (textNodeSize.height / 2) - rectLeftPadding);
            noteReact.attr("y", yPoint + (extraSpaceToNote / 2))
        }

        function callShowTooltip(topPosition, leftPosition, childrenData, mainDivRef) {
            d3.select(mainDivRef).select(".custom-tooltip").remove();
            const tooltipMain = d3.select(mainDivRef).append("div")
                .attr("class", "custom-tooltip");
            tooltipMain.style("left", "0px");
            tooltipMain.append("div").html(childrenData);
            tooltipMain.append("div")
                .attr("class", "rectangle-container")
                .append("div")
                .attr("class", "rectangle-div");

            tooltipMain.style("top", (topPosition - (tooltipMain.node().getBoundingClientRect().height + 20)) + "px")
                .style("left", (leftPosition - (tooltipMain.node().getBoundingClientRect().width / 2)) + "px");
        }

        function callHideTooltip(mainDivRef) {
            d3.select(mainDivRef).select(".custom-tooltip").remove();
        }


        function calculateDataOnClick(source) {
            const mousePoint = d3.mouse(source);
            if ((mousePoint[0] < widthForWaterOilYAxis || mousePoint[0] > widthForMiddleAreaWithWaterOilYAxis || mousePoint[1] > chartHeight)) {
                return [];
            }
            const x = mousePoint[0] - (widthForWaterOilYAxis);
            const y = mousePoint[1];
            // console.log("data:",x,y);
            const selectedPointsGas = [];
            const selectedPointsWater = [];
            const selectedPointsOil = [];
            const xValue = xScaleLasso(xScaleLasso.invert(x));
            const yValueGas = yScaleGasLasso(yScaleGasLasso.invert(y));
            const yValueWater = yScaleWaterLasso(yScaleWaterLasso.invert(y));
            const yValueOil = yScaleOilLasso(yScaleOilLasso.invert(y));
            // section
            d3.selectAll("circle").each(data => {
                if (data != undefined && data.section.toLowerCase() == 'gas') {
                    const cx = xScaleLasso(data.x);
                    const cy = yScaleGasLasso(data.y);
                    if (xValue >= (cx - circleRadius) && xValue <= (cx + circleRadius) && yValueGas >= (cy - circleRadius) && yValueGas <= (cy + circleRadius)) {
                        selectedPointsGas.push(data);
                    }
                }

                if (data != undefined && data.section.toLowerCase() == 'water') {
                    const cx = xScaleLasso(data.x);
                    const cy = yScaleWaterLasso(data.y);
                    if (xValue >= (cx - circleRadius) && xValue <= (cx + circleRadius) && yValueWater >= (cy - circleRadius) && yValueWater <= (cy + circleRadius)) {
                        selectedPointsWater.push(data);
                    }
                }

                if (data != undefined && data.section.toLowerCase() == 'oil') {
                    const cx = xScaleLasso(data.x);
                    const cy = yScaleOilLasso(data.y);
                    if (xValue >= (cx - circleRadius) && xValue <= (cx + circleRadius) && yValueOil >= (cy - circleRadius) && yValueOil <= (cy + circleRadius)) {
                        selectedPointsOil.push(data);
                    }
                }
            })
            const allSelectedPoints = [...selectedPointsGas, ...selectedPointsWater, ...selectedPointsOil];
            return allSelectedPoints;

        }
        const lasso_area = svgForLines
            .append("rect")
            .attr("class", "lasso-area-rect")
            .attr("x", 0)
            .attr("y", 0)
            .attr("width", chartWidth)
            .attr("height", chartHeight)
            .style("opacity", 0);

        const areaForNotes = svgForLines
            .append("g")
            .attr("class", 'area-for-note');

        var lasso_start = function () {
            // lassoEndSelectionG.html('');
            lasso.items()
                .attr("r", circleRadius) // reset size
                .classed("not_possible", true)
                .classed("selected", false);
        };

        var lasso_draw = function () {

            // Style the possible dots
            lasso.possibleItems()
                .classed("not_possible", false)
                .classed("possible", true);

            // Style the not possible dot
            lasso.notPossibleItems()
                .classed("not_possible", true)
                .classed("possible", false);
        };
        let lassoSelectedData = [];

        var lasso_end = function () {
            console.log("lasso_end");
            zoom_area.transition().duration(10).style("pointer-events", "all");
            zoom_area.on('.zoom', null);
            zoom_area.call(zoomdefination);

            console.log(zoom_area);
            // Reset the color of all dots
            lasso.items()
                .classed("not_possible", false)
                .classed("possible", false);

            const data = [];
            lasso.selectedItems().each(d => {
                if (d != undefined)
                    data.push(d)
            })
            // console.log("Selected Items:", data);
            lassoSelectedData = [...lassoSelectedData, ...data];
            console.log("lassoSelectedData:", lassoSelectedData);
            lassoEndSelectionG.html('');
            lassoEndSelectionG
                .selectAll("circle")
                .data(lassoSelectedData)
                .enter()
                .append("circle")
                .datum(d => d)
                .attr("cx", d => xScaleLasso(d.x))
                .attr("cy", d => {
                    if (d.section.toLowerCase() == 'oil')
                        return yScaleOilLasso((d.y) * lassoMultiplier)
                    else if (d.section.toLowerCase() == 'gas')
                        return yScaleGasLasso(d.y * lassoMultiplier)
                    else if (d.section.toLowerCase() == 'water')
                        return yScaleWaterLasso((d.y) * lassoMultiplier)
                })
                .attr("class", d => {
                    if (d.section.toLowerCase() == 'oil')
                        return "lasso-selected-oil"
                    else if (d.section.toLowerCase() == 'gas')
                        return "lasso-selected-gas"
                    else if (d.section.toLowerCase() == 'water')
                        return "lasso-selected-water"
                })
                .attr("r", circleRadius)
                .style("fill", d => d.colors);


            lassoEndSelectionG
                .selectAll("rect")
                .data(lassoSelectedData)
                .enter()
                .append("rect")
                .datum(d => d)
                .attr("x", d => xScaleLasso(d.x) - (circleRadius * 2))
                .attr("y", d => {
                    if (d.section.toLowerCase() == 'oil')
                        return yScaleOilLasso((d.y)) - (circleRadius * 2)
                    else if (d.section.toLowerCase() == 'gas')
                        return yScaleGasLasso(d.y) - (circleRadius * 2)
                    else if (d.section.toLowerCase() == 'water')
                        return yScaleWaterLasso((d.y)) - (circleRadius * 2)
                })
                .attr("width", circleRadius * 4)
                .attr("height", circleRadius * 4)
                .attr("class", d => {
                    if (d.section.toLowerCase() == 'oil')
                        return "lasso-selected-rect-oil"
                    else if (d.section.toLowerCase() == 'gas')
                        return "lasso-selected-rect-gas"
                    else if (d.section.toLowerCase() == 'water')
                        return "lasso-selected-rect-water"
                })
                .style("fill", "transparent")
                .style("stroke", selectedLassoRect);

            // Reset the style of the not selected dots
            lasso.notSelectedItems()
                .attr("r", circleRadius);
        };

        const lasso = d3.lasso()
            .closePathSelect(true)
            .closePathDistance(100)
            .items(d3.selectAll("circle"))
            .targetArea(lasso_area)
            .on("start", lasso_start)
            .on("draw", lasso_draw)
            .on("end", lasso_end);

        function getCalculatedTickSize() {

            if (!d3.event.transform) {
                return;
            }

            const k = d3.event.transform.k;
            const differenceFrom1 = (1 - d3.event.transform.k);
            let calculatedTickSize = k < 1 ? Math.round(7 + (50 * differenceFrom1)) : 7;
            calculatedTickSize = calculatedTickSize > 17 ? 17 : calculatedTickSize;
            calculatedTickSize = k < 0.5 ? 10 : calculatedTickSize;
            console.log(k, calculatedTickSize);
            return calculatedTickSize;
        }



        let zoomtransformYWater = {
            x: 0, y: 0, k: 1
        }, zoomtransformYGas = {
            x: 0, y: 0, k: 1
        }, zoomtransformYOil = {
            x: 0, y: 0, k: 1
        };
        let flagForZoom = 0;
        let initZoom = 0;
        function updateChartZoomEnd() {
            console.log("zoom end:");
            const mousePoint = d3.mouse(this);
            if (flagForZoom == 1) {
                initZoom = 1;
                flagForZoom = 0;
            } else {
                initZoom = 0;
            }

            const data = d3.zoomTransform(zoom_area.node());
            if (mousePoint[0] < 0 || mousePoint[0] > width) {
                return;
            } else if (mousePoint[0] > 0 && mousePoint[0] <= margin.left && mousePoint[1] > 0 && mousePoint[1] < chartHeight) {
                zoomtransformYWater = d3.event.transform;
                console.log("zoomtransformYWater:", zoomtransformYWater);
            } else if (mousePoint[0] > margin.left && mousePoint[0] <= widthForWaterOilYAxis && mousePoint[1] > 0 && mousePoint[1] < chartHeight) {
                zoomtransformYOil = d3.event.transform;
            } else if (mousePoint[0] > widthForMiddleAreaWithWaterOilYAxis && mousePoint[0] <= width && mousePoint[1] > 0 && mousePoint[1] < chartHeight) {
                zoomtransformYGas = d3.event.transform;
            }

            updateMajorGridLineStokeDashedStyle();
            updateMinorGridLineStokeDashedStyle();
        }

        function updateChartZoomStart() {
            if (initZoom == 0) {
                flagForZoom = 1;
            }
            console.log("zoom start:");
            const mousePoint = d3.mouse(this);
            if (mousePoint[0] < 0 || mousePoint[0] > width) {
                return;
            } else if (mousePoint[0] > 0 && mousePoint[0] <= margin.left && mousePoint[1] > 0 && mousePoint[1] < chartHeight) {
                console.log("Reset Water:", zoomtransformYWater);
                zoom_area.transition().duration(10).call(zoomdefination.transform, d3.zoomIdentity.translate(zoomtransformYWater.x, zoomtransformYWater.y).scale(zoomtransformYWater.k));
            } else if (mousePoint[0] > margin.left && mousePoint[0] <= widthForWaterOilYAxis && mousePoint[1] > 0 && mousePoint[1] < chartHeight) {
                console.log("Reset Oil:", zoomtransformYOil);
                zoom_area.transition().duration(10).call(zoomdefination.transform, d3.zoomIdentity.translate(zoomtransformYOil.x, zoomtransformYOil.y).scale(zoomtransformYOil.k));
            } else if (mousePoint[0] > widthForWaterOilYAxis && mousePoint[0] <= widthForMiddleAreaWithWaterOilYAxis && mousePoint[1] > 0 && mousePoint[1] < chartHeight) {
                //Center
            }
            else if (mousePoint[0] > widthForMiddleAreaWithWaterOilYAxis && mousePoint[0] <= width && mousePoint[1] > 0 && mousePoint[1] < chartHeight) {
                console.log("Reset Gas:", zoomtransformYGas);
                zoom_area.transition().duration(10).call(zoomdefination.transform, d3.zoomIdentity.translate(zoomtransformYGas.x, zoomtransformYGas.y).scale(zoomtransformYGas.k));
            }
            updateMajorGridLineStokeDashedStyle();
            updateMinorGridLineStokeDashedStyle();

        }

        function updateChart() {
            const mousePoint = d3.mouse(this);
            if (mousePoint[0] < 0 || mousePoint[0] > width) {
                return;
            } else if (mousePoint[0] > 0 && mousePoint[0] <= margin.left && mousePoint[1] > 0 && mousePoint[1] < chartHeight) {
                zoomtransformYWater = d3.event.transform;
            } else if (mousePoint[0] > margin.left && mousePoint[0] <= widthForWaterOilYAxis && mousePoint[1] > 0 && mousePoint[1] < chartHeight) {
                zoomtransformYOil = d3.event.transform;
            } else if (mousePoint[0] > widthForMiddleAreaWithWaterOilYAxis && mousePoint[0] <= width && mousePoint[1] > 0 && mousePoint[1] < chartHeight) {
                zoomtransformYGas = d3.event.transform;
            }


            // console.log("mousePoint:",mousePoint);
            const currentTransform = d3.event.transform;
            // console.log("currentTransform",currentTransform);
            if (mousePoint[0] < 0 || mousePoint[0] > width) {
                return;
            } else if (mousePoint[0] > 0 && mousePoint[0] <= margin.left && mousePoint[1] > 0 && mousePoint[1] < chartHeight) {
                zoomPanWaterOnlyYAxis();
            } else if (mousePoint[0] > margin.left && mousePoint[0] <= widthForWaterOilYAxis && mousePoint[1] > 0 && mousePoint[1] < chartHeight) {
                zoomPanOilOnlyYAxis();
            } else if (mousePoint[0] > widthForWaterOilYAxis && mousePoint[0] <= widthForMiddleAreaWithWaterOilYAxis && mousePoint[1] > 0 && mousePoint[1] < chartHeight) {
                axisGXAxis.call(xAxis.scale(d3.event.transform.rescaleX(xScale)));
                xScaleLasso.domain(d3.event.transform.rescaleX(xScale).domain());
                xScaleZoom = d3.event.transform.rescaleX(xScale);
                // xScale=xScaleZoom;
                updateTriangleText();
                zoomPanWaterOnly();
                zoomPanOilOnly();
                zoomPanGasOnly();
            } else if (mousePoint[0] > widthForMiddleAreaWithWaterOilYAxis && mousePoint[0] <= width && mousePoint[1] > 0 && mousePoint[1] < chartHeight) {
                zoomPanGasOnlyYAxis();
            } else if (mousePoint[1] > widthForWaterOilYAxis && mousePoint[1] < heightForMiddleAreaWithMarginBottom && mousePoint[0] > widthForWaterOilYAxis && mousePoint[0] < widthForMiddleAreaWithWaterOilYAxis) {
                zoomOnlyXAxis();
            }

            updateMajorGridLineStokeDashedStyle();
            updateMinorGridLineStokeDashedStyle();
        }

        function zoomOnlyXAxis() {
            // const xScaleToUSe=xScaleZoom!=null ? xScaleZoom : xScale;
            axisGXAxis.call(xAxis.scale(d3.event.transform.rescaleX(xScale)));
            xScaleLasso.domain(d3.event.transform.rescaleX(xScale).domain());
            xScaleZoom = d3.event.transform.rescaleX(xScale);
            // xScale=xScaleZoom;
                updateTriangleText();
            zoomPanGasOnlyXAxis();
            zoomPanOilOnlyXAxis();
            zoomPanWaterOnlyXAxis();
        }

        function zoomPanGasOnlyXAxis() {
            //GAS Start
            const yScaleToUSeGas = yScaleGasZoom != null ? yScaleGasZoom : yScaleGas;
            const xScaleToUSe = xScaleZoom != null ? xScaleZoom : xScale;
            noteLabelsGas.forEach(notes => {
                const xPoint = xScaleToUSe(notes.x);
                const yPoint = yScaleToUSeGas(notes.y);
                fixedPositionOfNote(notes.noteReact, notes.textNode, xPoint, yPoint);
            });
            d3.select(".daily-data-container").selectAll(".circle-daily-gas")
                .attr("cx", d => (xScaleToUSe)(d.x))
                .attr("cy", d => yScaleToUSeGas(d.y));

            d3.select(".lasso-selected-container").selectAll(".lasso-selected-gas")
                .attr("cx", d => (xScaleToUSe)(d.x))
                .attr("cy", d => yScaleToUSeGas((d.y) * lassoMultiplier));

            d3.select(".lasso-selected-container").selectAll(".lasso-selected-rect-gas")
                .attr("x", d => (xScaleToUSe)(d.x) - (circleRadius * 2))
                .attr("y", d => yScaleToUSeGas((d.y)) - (circleRadius * 2));
            d3.select(".line-gas").selectAll("circle")
                .attr("cx", d => (xScaleToUSe)(d.x))
                .attr("cy", d => yScaleToUSeGas(d.y));

            const updatedLineGas = d3.line()
                .curve(d3.curveStepBefore)
                .x(d => ((xScaleToUSe)(d.x)))
                .y(d => yScaleToUSeGas(d.y));

            d3.select(".line-gas")
                .select("path")
                .attr("d", updatedLineGas);
            // GAS End
        }

        function zoomPanGasOnlyYAxis() {
            //GAS Start
            axisGGas.call(yAxisGas.scale(d3.event.transform.rescaleY(yScaleGas)));
            const xScaleToUSe = xScaleZoom != null ? xScaleZoom : xScale;
            noteLabelsGas.forEach(notes => {
                const xPoint = xScaleToUSe(notes.x);
                const yPoint = d3.event.transform.rescaleY(notes.yScaleToUse)(notes.y);
                fixedPositionOfNote(notes.noteReact, notes.textNode, xPoint, yPoint);
            });
            d3.select(".daily-data-container").selectAll(".circle-daily-gas")
                .attr("cx", d => (xScaleToUSe)(d.x))
                .attr("cy", d => d3.event.transform.rescaleY(yScaleGas)(d.y));

            d3.select(".lasso-selected-container").selectAll(".lasso-selected-gas")
                .attr("cx", d => (xScaleToUSe)(d.x))
                .attr("cy", d => d3.event.transform.rescaleY(yScaleGas)((d.y) * lassoMultiplier));

            d3.select(".lasso-selected-container").selectAll(".lasso-selected-rect-gas")
                .attr("x", d => (xScaleToUSe)(d.x) - (circleRadius * 2))
                .attr("y", d => d3.event.transform.rescaleY(yScaleGas)((d.y)) - (circleRadius * 2));
            d3.select(".line-gas").selectAll("circle")
                .attr("cx", d => (xScaleToUSe)(d.x))
                .attr("cy", d => d3.event.transform.rescaleY(yScaleGas)(d.y));

            const updatedLineGas = d3.line()
                .curve(d3.curveStepBefore)
                .x(d => ((xScaleToUSe)(d.x)))
                .y(d => d3.event.transform.rescaleY(yScaleGas)(d.y));

            d3.select(".line-gas")
                .select("path")
                .attr("d", updatedLineGas);

            yScaleGasLasso.domain(d3.event.transform.rescaleY(yScaleGas).domain());
            yScaleGasZoom = d3.event.transform.rescaleY(yScaleGas);
            // GAS End
        }

        function zoomPanGasOnly() {
            //GAS Start
            axisGGas.call(yAxisGas.scale(d3.event.transform.rescaleY(yScaleGas)));
            noteLabelsGas.forEach(notes => {
                const xPoint = d3.event.transform.rescaleX(notes.xScaleToUSe)(notes.x);
                const yPoint = d3.event.transform.rescaleY(notes.yScaleToUse)(notes.y);
                fixedPositionOfNote(notes.noteReact, notes.textNode, xPoint, yPoint);
            });
            yScaleGasZoom = d3.event.transform.rescaleY(yScaleGas);
            d3.select(".daily-data-container").selectAll(".circle-daily-gas")
                .attr("cx", d => d3.event.transform.rescaleX(xScale)(d.x))
                .attr("cy", d => d3.event.transform.rescaleY(yScaleGas)(d.y));

            d3.select(".lasso-selected-container").selectAll(".lasso-selected-gas")
                .attr("cx", d => d3.event.transform.rescaleX(xScale)(d.x))
                .attr("cy", d => d3.event.transform.rescaleY(yScaleGas)((d.y) * lassoMultiplier));

            d3.select(".lasso-selected-container").selectAll(".lasso-selected-rect-gas")
                .attr("x", d => d3.event.transform.rescaleX(xScale)(d.x) - (circleRadius * 2))
                .attr("y", d => d3.event.transform.rescaleY(yScaleGas)((d.y)) - (circleRadius * 2));

            d3.select(".line-gas").selectAll("circle")
                .attr("cx", d => d3.event.transform.rescaleX(xScale)(d.x))
                .attr("cy", d => d3.event.transform.rescaleY(yScaleGas)(d.y));

            const updatedLineGas = d3.line()
                .curve(d3.curveStepBefore)
                .x(d => (d3.event.transform.rescaleX(xScale)(d.x)))
                .y(d => d3.event.transform.rescaleY(yScaleGas)(d.y));

            d3.select(".line-gas")
                .select("path")
                .attr("d", updatedLineGas);

            yScaleGasLasso.domain(d3.event.transform.rescaleY(yScaleGas).domain());
            // GAS End
        }

        function zoomPanOilOnlyXAxis() {
            //Oil start
            const yScaleToUSeOil = yScaleOilZoom != null ? yScaleOilZoom : yScaleOil;
            const xScaleToUSe = xScaleZoom != null ? xScaleZoom : xScale;
            noteLabelsOil.forEach(notes => {
                const xPoint = (xScaleToUSe)(notes.x);
                const yPoint = yScaleToUSeOil(notes.y);
                fixedPositionOfNote(notes.noteReact, notes.textNode, xPoint, yPoint);
            });
            d3.select(".daily-data-container").selectAll(".circle-daily-oil")
                .attr("cx", d => (xScaleToUSe)(d.x))
                .attr("cy", d => yScaleToUSeOil(d.y));

            d3.select(".lasso-selected-container").selectAll(".lasso-selected-oil")
                .attr("cx", d => (xScaleToUSe)(d.x))
                .attr("cy", d => yScaleToUSeOil((d.y) * lassoMultiplier));

            d3.select(".lasso-selected-container").selectAll(".lasso-selected-rect-oil")
                .attr("x", d => (xScaleToUSe)(d.x) - (circleRadius * 2))
                .attr("y", d => yScaleToUSeOil((d.y)) - (circleRadius * 2));

            d3.select(".line-oil").selectAll("circle")
                .attr("cx", d => (xScaleToUSe)(d.x))
                .attr("cy", d => yScaleToUSeOil(d.y));

            const updatedLineOil = d3.line()
                .curve(d3.curveStepBefore)
                .x(d => ((xScaleToUSe)(d.x)))
                .y(d => yScaleToUSeOil(d.y));

            d3.select(".line-oil")
                .select("path")
                .attr("d", updatedLineOil);

            //Oil End
        }

        function zoomPanOilOnlyYAxis() {
            //Oil start
            const calculatedTickSize = getCalculatedTickSize();
            axisGOil.call(yAxisOil.scale(d3.event.transform.rescaleY(yScaleOil)).ticks(calculatedTickSize, ".0f"));

            const xScaleToUSe = xScaleZoom != null ? xScaleZoom : xScale;
            noteLabelsOil.forEach(notes => {
                const xPoint = (xScaleToUSe)(notes.x);
                const yPoint = d3.event.transform.rescaleY(notes.yScaleToUse)(notes.y);
                fixedPositionOfNote(notes.noteReact, notes.textNode, xPoint, yPoint);
            });
            d3.select(".daily-data-container").selectAll(".circle-daily-oil")
                .attr("cx", d => (xScaleToUSe)(d.x))
                .attr("cy", d => d3.event.transform.rescaleY(yScaleOil)(d.y));

            d3.select(".lasso-selected-container").selectAll(".lasso-selected-oil")
                .attr("cx", d => (xScaleToUSe)(d.x))
                .attr("cy", d => d3.event.transform.rescaleY(yScaleOil)((d.y) * lassoMultiplier));

            d3.select(".lasso-selected-container").selectAll(".lasso-selected-rect-oil")
                .attr("x", d => (xScaleToUSe)(d.x) - (circleRadius * 2))
                .attr("y", d => d3.event.transform.rescaleY(yScaleOil)((d.y)) - (circleRadius * 2));

            d3.select(".line-oil").selectAll("circle")
                .attr("cx", d => (xScaleToUSe)(d.x))
                .attr("cy", d => d3.event.transform.rescaleY(yScaleOil)(d.y));

            const updatedLineOil = d3.line()
                .curve(d3.curveStepBefore)
                .x(d => ((xScaleToUSe)(d.x)))
                .y(d => d3.event.transform.rescaleY(yScaleOil)(d.y));

            d3.select(".line-oil")
                .select("path")
                .attr("d", updatedLineOil);

            yScaleOilLasso.domain(d3.event.transform.rescaleY(yScaleOil).domain());
            yScaleOilZoom = d3.event.transform.rescaleY(yScaleOil);
            //Oil End
        }

        function zoomPanOilOnly() {
            const calculatedTickSize = getCalculatedTickSize();
            axisGOil.call(yAxisOil.scale(d3.event.transform.rescaleY(yScaleOil)).ticks(calculatedTickSize, ".0f"));

            noteLabelsOil.forEach(notes => {
                const xPoint = d3.event.transform.rescaleX(notes.xScaleToUSe)(notes.x);
                const yPoint = d3.event.transform.rescaleY(notes.yScaleToUse)(notes.y);
                fixedPositionOfNote(notes.noteReact, notes.textNode, xPoint, yPoint);
            });
            yScaleOilZoom = d3.event.transform.rescaleY(yScaleOil);
            d3.select(".daily-data-container").selectAll(".circle-daily-oil")
                .attr("cx", d => d3.event.transform.rescaleX(xScale)(d.x))
                .attr("cy", d => d3.event.transform.rescaleY(yScaleOil)(d.y));

            d3.select(".lasso-selected-container").selectAll(".lasso-selected-oil")
                .attr("cx", d => d3.event.transform.rescaleX(xScale)(d.x))
                .attr("cy", d => d3.event.transform.rescaleY(yScaleOil)((d.y) * lassoMultiplier));

            d3.select(".lasso-selected-container").selectAll(".lasso-selected-rect-oil")
                .attr("x", d => d3.event.transform.rescaleX(xScale)(d.x) - (circleRadius * 2))
                .attr("y", d => d3.event.transform.rescaleY(yScaleOil)((d.y)) - (circleRadius * 2));

            d3.select(".line-oil").selectAll("circle")
                .attr("cx", d => d3.event.transform.rescaleX(xScale)(d.x))
                .attr("cy", d => d3.event.transform.rescaleY(yScaleOil)(d.y));

            const updatedLineOil = d3.line()
                .curve(d3.curveStepBefore)
                .x(d => (d3.event.transform.rescaleX(xScale)(d.x)))
                .y(d => d3.event.transform.rescaleY(yScaleOil)(d.y));

            d3.select(".line-oil")
                .select("path")
                .attr("d", updatedLineOil);

            yScaleOilLasso.domain(d3.event.transform.rescaleY(yScaleOil).domain());
            //Oil End
        }

        function zoomPanWaterOnlyXAxis() {
            //Water Start
            const yScaleToUSeWater = yScaleWaterZoom != null ? yScaleWaterZoom : yScaleWater;
            const xScaleToUSe = xScaleZoom != null ? xScaleZoom : xScale;
            noteLabelsWater.forEach(notes => {
                const xPoint = xScaleToUSe(notes.x);
                const yPoint = yScaleToUSeWater(notes.y);
                fixedPositionOfNote(notes.noteReact, notes.textNode, xPoint, yPoint);
            });
            d3.select(".daily-data-container").selectAll(".circle-daily-water")
                .attr("cx", d => (xScaleToUSe)(d.x))
                .attr("cy", d => yScaleToUSeWater(d.y));
            d3.select(".lasso-selected-container").selectAll(".lasso-selected-water")
                .attr("cx", d => (xScaleToUSe)(d.x))
                .attr("cy", d => yScaleToUSeWater((d.y) * lassoMultiplier));


            d3.select(".lasso-selected-container").selectAll(".lasso-selected-rect-water")
                .attr("x", d => (xScaleToUSe)(d.x) - (circleRadius * 2))
                .attr("y", d => yScaleToUSeWater((d.y)) - (circleRadius * 2));

            d3.select(".line-water").selectAll("circle")
                .attr("cx", d => (xScaleToUSe)(d.x))
                .attr("cy", d => yScaleToUSeWater(d.y));

            const updatedLineWater = d3.line()
                .curve(d3.curveStepBefore)
                .x(d => ((xScaleToUSe)(d.x)))
                .y(d => yScaleToUSeWater(d.y));

            d3.select(".line-water")
                .select("path")
                .attr("d", updatedLineWater);
            //Water End
        }


        function zoomPanWaterOnlyYAxis() {
            //Water Start
            axisGWater.call(yAxisWater.scale(d3.event.transform.rescaleY(yScaleWater)));
            const xScaleToUSe = xScaleZoom != null ? xScaleZoom : xScale;
            noteLabelsWater.forEach(notes => {
                const xPoint = xScaleToUSe(notes.x);
                const yPoint = d3.event.transform.rescaleY(notes.yScaleToUse)(notes.y);
                fixedPositionOfNote(notes.noteReact, notes.textNode, xPoint, yPoint);
            });
            d3.select(".daily-data-container").selectAll(".circle-daily-water")
                .attr("cx", d => (xScaleToUSe)(d.x))
                .attr("cy", d => d3.event.transform.rescaleY(yScaleWater)(d.y));
            d3.select(".lasso-selected-container").selectAll(".lasso-selected-water")
                .attr("cx", d => (xScaleToUSe)(d.x))
                .attr("cy", d => d3.event.transform.rescaleY(yScaleWater)((d.y) * lassoMultiplier));

            d3.select(".lasso-selected-container").selectAll(".lasso-selected-rect-water")
                .attr("x", d => (xScaleToUSe)(d.x) - (circleRadius * 2))
                .attr("y", d => d3.event.transform.rescaleY(yScaleWater)((d.y)) - (circleRadius * 2));

            d3.select(".line-water").selectAll("circle")
                .attr("cx", d => (xScaleToUSe)(d.x))
                .attr("cy", d => d3.event.transform.rescaleY(yScaleWater)(d.y));

            const updatedLineWater = d3.line()
                .curve(d3.curveStepBefore)
                .x(d => ((xScaleToUSe)(d.x)))
                .y(d => d3.event.transform.rescaleY(yScaleWater)(d.y));

            d3.select(".line-water")
                .select("path")
                .attr("d", updatedLineWater);
            yScaleWaterLasso.domain(d3.event.transform.rescaleY(yScaleWater).domain());
            yScaleWaterZoom = d3.event.transform.rescaleY(yScaleWater);
            //Water End
        }


        function zoomPanWaterOnly() {
            //Water Start
            // const yScaleToUSeWater=yScaleWaterZoom!=null ? yScaleWaterZoom : yScaleWater;
            axisGWater.call(yAxisWater.scale(d3.event.transform.rescaleY(yScaleWater)));
            noteLabelsWater.forEach(notes => {
                const xPoint = d3.event.transform.rescaleX(notes.xScaleToUSe)(notes.x);
                const yPoint = d3.event.transform.rescaleY(notes.yScaleToUse)(notes.y);
                fixedPositionOfNote(notes.noteReact, notes.textNode, xPoint, yPoint);
            });

            d3.select(".daily-data-container").selectAll(".circle-daily-water")
                .attr("cx", d => d3.event.transform.rescaleX(xScale)(d.x))
                .attr("cy", d => d3.event.transform.rescaleY(yScaleWater)(d.y));
            d3.select(".lasso-selected-container").selectAll(".lasso-selected-water")
                .attr("cx", d => d3.event.transform.rescaleX(xScale)(d.x))
                .attr("cy", d => d3.event.transform.rescaleY(yScaleWater)((d.y) * lassoMultiplier));

            d3.select(".lasso-selected-container").selectAll(".lasso-selected-rect-water")
                .attr("x", d => d3.event.transform.rescaleX(xScale)(d.x) - (circleRadius * 2))
                .attr("y", d => d3.event.transform.rescaleY(yScaleWater)((d.y)) - (circleRadius * 2));

            d3.select(".line-water").selectAll("circle")
                .attr("cx", d => d3.event.transform.rescaleX(xScale)(d.x))
                .attr("cy", d => d3.event.transform.rescaleY(yScaleWater)(d.y));

            const updatedLineWater = d3.line()
                .curve(d3.curveStepBefore)
                .x(d => (d3.event.transform.rescaleX(xScale)(d.x)))
                .y(d => d3.event.transform.rescaleY(yScaleWater)(d.y));

            d3.select(".line-water")
                .select("path")
                .attr("d", updatedLineWater);
            yScaleWaterLasso.domain(d3.event.transform.rescaleY(yScaleWater).domain());
            yScaleWaterZoom = d3.event.transform.rescaleY(yScaleWater);
            //Water End
        }

        function zoomPanWaterOnlyOnRect(xScaleToUSe, yScaleToUSeWater, yScaleToUSeOil, yScaleToUSeGas) {
            //Water Start
            axisGXAxis.call(xAxis.scale(xScaleToUSe));
            xScaleZoom = xScaleToUSe;
            yScaleWaterZoom = yScaleToUSeWater;
            xScaleLasso.domain(xScaleToUSe.domain());
            axisGWater.call(yAxisWater.scale(yScaleToUSeWater));
            noteLabelsWater.forEach(notes => {
                const xPoint = xScaleToUSe(notes.x);
                const yPoint = yScaleToUSeWater(notes.y);
                fixedPositionOfNote(notes.noteReact, notes.textNode, xPoint, yPoint);
            });
            d3.select(".daily-data-container").selectAll(".circle-daily-water")
                .attr("cx", d => xScaleToUSe(d.x))
                .attr("cy", d => yScaleToUSeWater(d.y));
            d3.select(".lasso-selected-container").selectAll(".lasso-selected-water")
                .attr("cx", d => xScaleToUSe(d.x))
                .attr("cy", d => yScaleToUSeWater((d.y) * lassoMultiplier));

            d3.select(".lasso-selected-container").selectAll(".lasso-selected-rect-water")
                .attr("x", d => xScaleToUSe(d.x) - (circleRadius * 2))
                .attr("y", d => yScaleToUSeWater((d.y)) - (circleRadius * 2));

            d3.select(".line-water").selectAll("circle")
                .attr("cx", d => xScaleToUSe(d.x))
                .attr("cy", d => yScaleToUSeWater(d.y));

            const updatedLineWater = d3.line()
                .curve(d3.curveStepBefore)
                .x(d => (xScaleToUSe(d.x)))
                .y(d => yScaleToUSeWater(d.y));

            d3.select(".line-water")
                .select("path")
                .attr("d", updatedLineWater);
            yScaleWaterLasso.domain(yScaleToUSeWater.domain());
            //Water End

            //Oil start
            const calculatedTickSize = getCalculatedTickSize();
            axisGOil.call(yAxisOil.scale(yScaleToUSeOil).ticks(calculatedTickSize, ".0f"));

            noteLabelsOil.forEach(notes => {
                const xPoint = xScaleToUSe(notes.x);
                const yPoint = yScaleToUSeOil(notes.y);
                fixedPositionOfNote(notes.noteReact, notes.textNode, xPoint, yPoint);
            });
            yScaleOilZoom = yScaleToUSeOil;
            d3.select(".daily-data-container").selectAll(".circle-daily-oil")
                .attr("cx", d => xScaleToUSe(d.x))
                .attr("cy", d => yScaleToUSeOil(d.y));

            d3.select(".lasso-selected-container").selectAll(".lasso-selected-oil")
                .attr("cx", d => xScaleToUSe(d.x))
                .attr("cy", d => yScaleToUSeOil((d.y) * lassoMultiplier));

            d3.select(".lasso-selected-container").selectAll(".lasso-selected-rect-oil")
                .attr("x", d => xScaleToUSe(d.x) - (circleRadius * 2))
                .attr("y", d => yScaleToUSeOil((d.y)) - (circleRadius * 2));

            d3.select(".line-oil").selectAll("circle")
                .attr("cx", d => xScaleToUSe(d.x))
                .attr("cy", d => yScaleToUSeOil(d.y));

            const updatedLineOil = d3.line()
                .curve(d3.curveStepBefore)
                .x(d => (xScaleToUSe(d.x)))
                .y(d => yScaleToUSeOil(d.y));

            d3.select(".line-oil")
                .select("path")
                .attr("d", updatedLineOil);

            yScaleOilLasso.domain(yScaleToUSeOil.domain());
            //Oil End

            //GAS Start
            axisGGas.call(yAxisGas.scale(yScaleToUSeGas));
            noteLabelsGas.forEach(notes => {
                const xPoint = xScaleToUSe(notes.x);
                const yPoint = yScaleToUSeGas(notes.y);
                fixedPositionOfNote(notes.noteReact, notes.textNode, xPoint, yPoint);
            });
            yScaleGasZoom = yScaleToUSeGas;
            d3.select(".daily-data-container").selectAll(".circle-daily-gas")
                .attr("cx", d => xScaleToUSe(d.x))
                .attr("cy", d => yScaleToUSeGas(d.y));

            d3.select(".lasso-selected-container").selectAll(".lasso-selected-gas")
                .attr("cx", d => xScaleToUSe(d.x))
                .attr("cy", d => yScaleToUSeGas((d.y) * lassoMultiplier));

            d3.select(".lasso-selected-container").selectAll(".lasso-selected-rect-gas")
                .attr("x", d => xScaleToUSe(d.x) - (circleRadius * 2))
                .attr("y", d => yScaleToUSeGas((d.y)) - (circleRadius * 2));

            d3.select(".line-gas").selectAll("circle")
                .attr("cx", d => xScaleToUSe(d.x))
                .attr("cy", d => yScaleToUSeGas(d.y));

            const updatedLineGas = d3.line()
                .curve(d3.curveStepBefore)
                .x(d => (xScaleToUSe(d.x)))
                .y(d => yScaleToUSeGas(d.y));

            d3.select(".line-gas")
                .select("path")
                .attr("d", updatedLineGas);

            yScaleGasLasso.domain(yScaleToUSeGas.domain());
            // GAS End
        }
        svgForLines.call(lasso);
        // zoom_area.on('.zoom', null);
        // zoom_area.call(zoom); 

    </script>
</body>

</html>